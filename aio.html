<!DOCTYPE html>
<!-- START: inst/pkgdown/templates/layout.html --><!-- Generated by pkgdown: do not edit by hand --><html lang="en" data-bs-theme="auto">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<title>Performance Profiling &amp; Optimisation (Python): All in One View</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="assets/themetoggle.js"></script><link rel="stylesheet" type="text/css" href="assets/styles.css">
<script src="assets/scripts.js" type="text/javascript"></script><!-- mathjax --><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      config: ["MMLorHTML.js"],
      jax: ["input/TeX","input/MathML","output/HTML-CSS","output/NativeMML", "output/PreviewHTML"],
      extensions: ["tex2jax.js","mml2jax.js","MathMenu.js","MathZoom.js", "fast-preview.js", "AssistiveMML.js", "a11y/accessibility-menu.js"],
      TeX: {
        extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
      },
      tex2jax: {
        inlineMath: [['\\(', '\\)']],
        displayMath: [ ['$$','$$'], ['\\[', '\\]'] ],
        processEscapes: true
      }
    });
    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><!-- Responsive Favicon for The Carpentries --><link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
<link rel="icon" href="assets/images/UOSSheild_Primary_Violet_RGB.ico" sizes="any">
<link rel="icon" href="assets/images/UOSSheild_Primary_Violet_RGB.svg" type="image/svg+xml">
<link rel="manifest" href="site.webmanifest">
<link rel="mask-icon" href="safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="white">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="black">
</head>
<body>
    <header id="top" class="navbar navbar-expand-md top-nav incubator"><svg xmlns="http://www.w3.org/2000/svg" class="d-none"><symbol id="check2" viewbox="0 0 16 16"><path d="M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z"></path></symbol><symbol id="circle-half" viewbox="0 0 16 16"><path d="M8 15A7 7 0 1 0 8 1v14zm0 1A8 8 0 1 1 8 0a8 8 0 0 1 0 16z"></path></symbol><symbol id="moon-stars-fill" viewbox="0 0 16 16"><path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"></path><path d="M10.794 3.148a.217.217 0 0 1 .412 0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217 0 0 1 0 .412l-1.162.387a1.734 1.734 0 0 0-1.097 1.097l-.387 1.162a.217.217 0 0 1-.412 0l-.387-1.162A1.734 1.734 0 0 0 9.31 6.593l-1.162-.387a.217.217 0 0 1 0-.412l1.162-.387a1.734 1.734 0 0 0 1.097-1.097l.387-1.162zM13.863.099a.145.145 0 0 1 .274 0l.258.774c.115.346.386.617.732.732l.774.258a.145.145 0 0 1 0 .274l-.774.258a1.156 1.156 0 0 0-.732.732l-.258.774a.145.145 0 0 1-.274 0l-.258-.774a1.156 1.156 0 0 0-.732-.732l-.774-.258a.145.145 0 0 1 0-.274l.774-.258c.346-.115.617-.386.732-.732L13.863.1z"></path></symbol><symbol id="sun-fill" viewbox="0 0 16 16"><path d="M8 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"></path></symbol></svg><a class="visually-hidden-focusable skip-link" href="#main-content">Skip to main content</a>
  <div class="container-fluid top-nav-container">
    <div class="col-md-8">
      <div class="large-logo">
        <a href="https://www.sheffield.ac.uk" class="external-link">
          <img alt="University of Sheffield" src="assets/images/UOSLogo_Primary_Violet_RGB.svg" class="light-only"><img alt="University of Sheffield" src="assets/images/UOSLogo_Primary_White_RGB.svg" class="dark-only"></a>

        <span class="badge text-bg-warning">
          <abbr title="This lesson is in the alpha phase, which means that it has been taught once and lesson authors are iterating on feedback.">
            <a href="https://cdh.carpentries.org/the-lesson-life-cycle.html#field-testing-alpha-stage" class="external-link alert-link">
              <i aria-hidden="true" class="icon" data-feather="alert-triangle" style="border-radius: 5px"></i>
              Alpha
            </a>
            <span class="visually-hidden">This lesson is in the alpha phase, which means that it has been taught once and lesson authors are iterating on feedback.</span>
          </abbr>
        </span>

      </div>
    </div>
    <div class="selector-container">
      <div id="theme-selector">
        <li class="nav-item dropdown" id="theme-button-list">
          <button class="btn btn-link nav-link px-0 px-lg-2 dropdown-toggle d-flex align-items-center" id="bd-theme" type="button" aria-expanded="false" data-bs-toggle="dropdown" data-bs-display="static" aria-label="Toggle theme (auto)">
            <svg class="bi my-1 theme-icon-active"><use href="#circle-half"></use></svg><i data-feather="chevron-down"></i>
          </button>
          <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="bd-theme-text">
<li>
              <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="light" aria-pressed="false">
                <svg class="bi me-2 theme-icon"><use href="#sun-fill"></use></svg>
                Light
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
            <li>
              <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="dark" aria-pressed="false">
                <svg class="bi me-2 theme-icon"><use href="#moon-stars-fill"></use></svg>
                Dark
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
            <li>
              <button type="button" class="btn dropdown-item d-flex align-items-center active" data-bs-theme-value="auto" aria-pressed="true">
                <svg class="bi me-2 theme-icon"><use href="#circle-half"></use></svg>
                Auto
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
          </ul>
</li>
      </div>

      <div class="dropdown" id="instructor-dropdown">
        <button class="btn btn-secondary dropdown-toggle bordered-button" type="button" id="dropdownMenu1" data-bs-toggle="dropdown" aria-expanded="false">
          <i aria-hidden="true" class="icon" data-feather="eye"></i> Learner View <i data-feather="chevron-down"></i>
        </button>
        <ul class="dropdown-menu" aria-labelledby="dropdownMenu1">
<li><button class="dropdown-item" type="button" onclick="window.location.href='instructor/aio.html';">Instructor View</button></li>
        </ul>
</div>
    </div>
  </div>
  <hr></header><nav class="navbar navbar-expand-xl bottom-nav incubator" aria-label="Main Navigation"><div class="container-fluid nav-container">
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle Navigation">
      <span class="navbar-toggler-icon"></span>
      <span class="menu-title">Menu</span>
    </button>
    <div class="nav-logo">
      <img class="small-logo" alt="University of Sheffield" src="assets/images/UOSSheild_Primary_Violet_RGB.svg">
</div>
    <div class="lesson-title-md">
      Performance Profiling &amp; Optimisation (Python)
    </div>
    <div class="search-icon-sm">
      <!-- TODO: do not show until we have search
        <i role="img" aria-label="Search the All In One page" data-feather="search"></i>
      -->
    </div>
    <div class="desktop-nav">
      <ul class="navbar-nav me-auto mb-2 mb-lg-0">
<li class="nav-item">
          <span class="lesson-title">
            Performance Profiling &amp; Optimisation (Python)
          </span>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="key-points.html">Key Points</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="reference.html#glossary">Glossary</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="profiles.html">Learner Profiles</a>
        </li>
        <li class="nav-item dropdown">
          <button class="nav-link dropdown-toggle" id="navbarDropdown" data-bs-toggle="dropdown" aria-expanded="false">
            More <i data-feather="chevron-down"></i>
          </button>
          <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
<li><a class="dropdown-item" href="registration.html">Registration Information</a></li>
<li><a class="dropdown-item" href="technical-appendix.html">Technical Appendix</a></li>
<li><a class="dropdown-item" href="acknowledgements.html">Acknowledgements</a></li>
<li><a class="dropdown-item" href="ppp.html">Performant Python Patterns (Talk)</a></li>
<li><a class="dropdown-item" href="reference.html">Reference</a></li>
          </ul>
</li>
      </ul>
</div>
    <!--
    <form class="d-flex col-md-2 search-form">
      <fieldset disabled>
      <input class="form-control me-2 searchbox" type="search" placeholder="" aria-label="">
        <button class="btn btn-outline-success tablet-search-button"  type="submit">
          <i class="search-icon" data-feather="search" role="img" aria-label="Search the All In One page"></i>
        </button>
      </fieldset>
    </form>
    -->
    <a id="search-button" class="btn btn-primary" href="aio.html" role="button" aria-label="Search the All In One page">Search the All In One page</a>
  </div>
<!--/div.container-fluid -->
</nav><div class="col-md-12 mobile-title">
  Performance Profiling &amp; Optimisation (Python)
</div>

<aside class="col-md-12 lesson-progress"><div style="width: %" class="percentage">
    %
  </div>
  <div class="progress incubator">
    <div class="progress-bar incubator" role="progressbar" style="width: %" aria-valuenow="" aria-label="Lesson Progress" aria-valuemin="0" aria-valuemax="100">
    </div>
  </div>
</aside><div class="container">
      <div class="row">
        <!-- START: inst/pkgdown/templates/navbar.html -->
<div id="sidebar-col" class="col-lg-4">
  <div id="sidebar" class="sidebar">
      <nav aria-labelledby="flush-headingEleven"><button role="button" aria-label="close menu" alt="close menu" aria-expanded="true" aria-controls="sidebar" class="collapse-toggle" data-collapse="Collapse " data-episodes="Episodes ">
          <i class="search-icon" data-feather="x" role="img"></i>
        </button>
        <div class="sidebar-inner">
          <div class="row mobile-row" id="theme-row-mobile">
            <div class="col" id="theme-selector">
              <li class="nav-item dropdown" id="theme-button-list">
                <button class="btn btn-link nav-link px-0 px-lg-2 dropdown-toggle d-flex align-items-center" id="bd-theme" type="button" aria-expanded="false" data-bs-toggle="dropdown" data-bs-display="static" aria-label="Toggle theme (auto)">
                  <svg class="bi my-1 theme-icon-active"><use href="#circle-half"></use></svg><span class="d-lg-none ms-1" id="bd-theme-text">Toggle Theme</span>
                </button>
                <ul class="dropdown-menu dropdown-menu-right" aria-labelledby="bd-theme-text">
<li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="light" aria-pressed="false">
                      <svg class="bi me-2 theme-icon"><use href="#sun-fill"></use></svg>
                      Light
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                  <li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="dark" aria-pressed="false">
                      <svg class="bi me-2 theme-icon"><use href="#moon-stars-fill"></use></svg>
                      Dark
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                  <li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center active" data-bs-theme-value="auto" aria-pressed="true">
                      <svg class="bi me-2 theme-icon"><use href="#circle-half"></use></svg>
                      Auto
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                </ul>
</li>
            </div>
          </div>
          <div class="row mobile-row">
            <div class="col">
              <div class="sidenav-view-selector">
                <div class="accordion accordion-flush" id="accordionFlush9">
                  <div class="accordion-item">
                    <h2 class="accordion-header" id="flush-headingNine">
                      <button class="accordion-button collapsed" id="instructor" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseNine" aria-expanded="false" aria-controls="flush-collapseNine">
                        <i id="eye" aria-hidden="true" class="icon" data-feather="eye"></i> Learner View
                      </button>
                    </h2>
                    <div id="flush-collapseNine" class="accordion-collapse collapse" aria-labelledby="flush-headingNine" data-bs-parent="#accordionFlush2">
                      <div class="accordion-body">
                        <a href="instructor/aio.html">Instructor View</a>
                      </div>
                    </div>
                  </div>
<!--/div.accordion-item-->
                </div>
<!--/div.accordion-flush-->
              </div>
<!--div.sidenav-view-selector -->
            </div>
<!--/div.col -->

            <hr>
</div>
<!--/div.mobile-row -->

          <div class="accordion accordion-flush" id="accordionFlush11">
            <div class="accordion-item">

              <button id="chapters" class="accordion-button show" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseEleven" aria-expanded="false" aria-controls="flush-collapseEleven">
                <h2 class="accordion-header chapters" id="flush-headingEleven">
                  EPISODES
                </h2>
              </button>
              <div id="flush-collapseEleven" class="accordion-collapse show collapse" aria-labelledby="flush-headingEleven" data-bs-parent="#accordionFlush11">

                <div class="accordion-body">
                  <div class="accordion accordion-flush" id="accordionFlush1">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading1">
        <a href="index.html">Summary and Setup</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush2">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading2">
        <a href="profiling-introduction.html">1. Introduction to Profiling</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush3">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading3">
        <a href="profiling-functions.html">2. Function Level Profiling</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush4">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading4">
        <a href="short-break1.html">3. Break</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush5">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading5">
        <a href="profiling-lines.html">4. Line Level Profiling</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush6">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading6">
        <a href="profiling-conclusion.html">5. Profiling Conclusion</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush7">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading7">
        <a href="optimisation-introduction.html">6. Introduction to Optimisation</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush8">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading8">
        <a href="optimisation-using-python.html">7. Using Python Language Features and the Standard Library</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush9">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading9">
        <a href="optimisation-data-structures-algorithms.html">8. Data Structures &amp; Algorithms</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush10">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading10">
        <a href="long-break1.html">9. Break</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush11">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading11">
        <a href="optimisation-numpy.html">10. Using Scientific Python Packages (NumPy, Pandas and more)</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush12">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading12">
        <a href="optimisation-use-latest.html">11. Keep Python &amp; Packages up to Date</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush13">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading13">
        <a href="optimisation-latency.html">12. Understanding Latency</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush14">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading14">
        <a href="optimisation-conclusion.html">13. Optimisation Conclusion</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

                </div>
              </div>
            </div>

            <hr class="half-width">
<div class="accordion accordion-flush lesson-resources" id="accordionFlush12">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-headingTwelve">
                  <button class="accordion-button collapsed" id="lesson-resources" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseTwelve" aria-expanded="false" aria-controls="flush-collapseTwelve">
                    RESOURCES
                  </button>
                </h2>
                <div id="flush-collapseTwelve" class="accordion-collapse collapse" aria-labelledby="flush-headingTwelve" data-bs-parent="#accordionFlush12">
                  <div class="accordion-body">
                    <ul>
<li>
                        <a href="key-points.html">Key Points</a>
                      </li>
                      <li>
                        <a href="reference.html#glossary">Glossary</a>
                      </li>
                      <li>
                        <a href="profiles.html">Learner Profiles</a>
                      </li>
                      <li><a href="registration.html">Registration Information</a></li>
<li><a href="technical-appendix.html">Technical Appendix</a></li>
<li><a href="acknowledgements.html">Acknowledgements</a></li>
<li><a href="ppp.html">Performant Python Patterns (Talk)</a></li>
<li><a href="reference.html">Reference</a></li>
                    </ul>
</div>
                </div>
              </div>
            </div>
            <hr class="half-width lesson-resources">
<a href="aio.html">See all in one page</a>


            <hr class="d-none d-sm-block d-md-none">
<div class="d-grid gap-1">

            </div>
          </div>
<!-- /div.accordion -->
        </div>
<!-- /div.sidebar-inner -->
      </nav>
</div>
<!-- /div.sidebar -->
  </div>
<!-- /div.sidebar-col -->
<!-- END:   inst/pkgdown/templates/navbar.html-->

        <!-- START: inst/pkgdown/templates/content-extra.html -->
  <div class="col-xl-8 col-lg-12 primary-content">
    <main id="main-content" class="main-content"><div class="container lesson-content">
        
        
<section id="aio-profiling-introduction"><p>Content from <a href="profiling-introduction.html">Introduction to Profiling</a></p>
<hr>
<p>Last updated on 2025-03-24 |

        <a href="https://github.com/RSE-Sheffield/pando-python/edit/main/episodes/profiling-introduction.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>Why should you profile your code?</li>
<li>How should you choose which type of profiler to use?</li>
<li>Which test case should be profiled?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>explain the benefits of profiling code and different types of
profiler</li>
<li>identify the appropriate Python profiler for a given scenario</li>
<li>explain how to select an appropriate test case for profiling and
why</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<hr class="half-width">
<!-- Profiling is (what) --><p>Performance profiling is the process of analysing and measuring the
performance of a program or script, to understand where time is being
spent during execution.</p>
<!-- It can be used for (where) -->
<p>Profiling is useful when you have written any code that will be
running for a substantial period of time. As your code grows in
complexity, it becomes increasingly difficult to estimate where time is
being spent during execution. Profiling allows you to narrow down where
the time is being spent, to identify whether this is of concern or
not.</p>
<!-- This allows enables faster/more (why) -->
<p>Profiling is a relatively quick process which can either provide you
the peace of mind that your code is efficient, or highlight the
performance bottleneck. There is limited benefit to optimising
components that may only contribute a tiny proportion of the overall
runtime. Identifying bottlenecks allows optimisation to be precise and
efficient, potentially leading to significant speedups enabling faster
research. In extreme cases, addressing bottlenecks has enabled programs
to run hundreds or thousands of times faster!</p>
<!-- Increasingly, concern for green/eco compute and or cloud costs (why) -->
<p>Increasingly, particularly with relation to HPC, attention is being
paid to the energy usage of software. Profiling your software will
provide you the confidence that your software is an efficient use of
resources.</p>
</section><section><h2 class="section-heading" id="when-to-profile">When to Profile<a class="anchor" aria-label="anchor" href="#when-to-profile"></a>
</h2>
<hr class="half-width">
<p>Profiling is most relevant to working code, when you have reached a
stage that the code works and are considering deploying it.</p>
<p>Any code that will run for more than a few minutes over its lifetime
and isn’t a quick one-off script can benefit from profiling.</p>
<p>Profiling should be a relatively quick and inexpensive process. If
there are no significant bottlenecks in your code you can quickly be
confident that your code is reasonably optimised. If you do identify a
concerning bottleneck, further work to optimise your code and reduce the
bottleneck could see significant improvements to the performance of your
code and hence productivity.</p>
<div id="all-programmers-can-benefit" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="all-programmers-can-benefit" class="callout-inner">
<h3 class="callout-title">All Programmers Can Benefit</h3>
<div class="callout-content">
<!-- Everyone benefits (why) -->
<p>Even professional programmers make oversights that can lead to poor
performance, and can be identified through profiling.</p>
<p>For example Grand Theft Auto Online, which has allegedly earned over
$7bn since it’s 2013 release, was notorious for it’s slow loading times.
8 years after it’s release <a href="https://nee.lv/2021/02/28/How-I-cut-GTA-Online-loading-times-by-70/" class="external-link">a
‘hacker’</a> had enough, they reverse engineered and profiled the code
to enable a 70% speedup!</p>
<p><em>How much revenue did that unnecessary bottleneck cost, through
user churn?</em></p>
<p><em>How much time and energy was wasted, by unnecessarily slow
loading screens?</em></p>

</div>
</div>
</div>
</section><section><h2 class="section-heading" id="types-of-profiler">Types of Profiler<a class="anchor" aria-label="anchor" href="#types-of-profiler"></a>
</h2>
<hr class="half-width">
<p>There are multiple approaches to profiling, most programming
languages have one or more tools available covering these approaches.
Whilst these tools differ, their core functionality can be grouped into
several categories.</p>
<div class="section level3">
<h3 id="manual-profiling">Manual Profiling<a class="anchor" aria-label="anchor" href="#manual-profiling"></a>
</h3>
<p>Similar to using <code>print()</code> for debugging, manually timing
sections of code can provide a rudimentary form of profiling.</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>t_a <span class="op">=</span> time.monotonic()</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="co"># A: Do something</span></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>t_b <span class="op">=</span> time.monotonic()</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="co"># B: Do something else</span></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>t_c <span class="op">=</span> time.monotonic()</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a><span class="co"># C: Do another thing</span></span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a>t_d <span class="op">=</span> time.monotonic()</span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a>mainTimer_stop <span class="op">=</span> time.monotonic()</span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"A: </span><span class="sc">{</span>t_b <span class="op">-</span> t_a<span class="sc">}</span><span class="ss"> seconds"</span>)</span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"B: </span><span class="sc">{</span>t_c <span class="op">-</span> t_b<span class="sc">}</span><span class="ss"> seconds"</span>)</span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"C: </span><span class="sc">{</span>t_d <span class="op">-</span> t_c<span class="sc">}</span><span class="ss"> seconds"</span>)</span></code></pre>
</div>
<p><em>Above is only one example of how you could manually profile your
Python code, there are many similar techniques.</em></p>
<p>Whilst this can be appropriate for profiling narrow sections of code,
it becomes increasingly impractical as a project grows in size and
complexity. Furthermore, it’s also unproductive to be routinely adding
and removing these small changes if they interfere with the required
outputs of a project.</p>
<div id="benchmarking" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="benchmarking" class="callout-inner">
<h3 class="callout-title">Benchmarking</h3>
<div class="callout-content">
<p>You may have previously used <a href="https://docs.python.org/3/library/timeit.html" class="external-link"><code>timeit</code></a>
for timing Python code.</p>
<p>This package returns the <strong>total runtime</strong> of an
isolated block of code, without providing a more granular timing
breakdown. Therefore, it is better described as a tool for
<strong>benchmarking</strong>.</p>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="function-level-profiling">Function-Level Profiling<a class="anchor" aria-label="anchor" href="#function-level-profiling"></a>
</h3>
<!-- Context -->
<p>Software is typically comprised of a hierarchy of function calls,
both functions written by the developer and those used from the
language’s standard library and third party packages.</p>
<!-- What -->
<p>Function-level profiling analyses where time is being spent with
respect to functions. Typically, function-level profiling will calculate
the number of times each function is called and the total time spent
executing each function, inclusive and exclusive of child function
calls.</p>
<!-- Why -->
<p>This allows functions that occupy a disproportionate amount of the
total runtime to be quickly identified and investigated.</p>
<!-- We will be covering -->
<p>In this course we will cover the usage of the function-level profiler
<code>cProfile</code> and how it’s output can be visualised with
<code>snakeviz</code>.</p>
</div>
<div class="section level3">
<h3 id="line-level-profiling">Line-Level Profiling<a class="anchor" aria-label="anchor" href="#line-level-profiling"></a>
</h3>
<!-- Context -->
<p>Function-level profiling may not always be granular enough, perhaps
your software is a single long script, or function-level profiling
highlighted a particularly complex function.</p>
<!-- What -->
<p>Line-level profiling provides greater granularity, analysing where
time is being spent with respect to individual lines of code.</p>
<!-- Why -->
<p>This will identify individual lines of code that occupy an
disproportionate amount of the total runtime.</p>
<!-- Caveat (too early to introduce this?) -->
<!-- Typically, function-level profiling should be attempted first as it has a greater signal-to-noise ratio and is often significantly cheaper to perform. -->
<!-- We will be covering -->
<p>In this course we will cover the usage of the line-level profiler
<code>line_profiler</code>.</p>
<div id="deterministic-vs-sampling-profilers" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="deterministic-vs-sampling-profilers" class="callout-inner">
<h3 class="callout-title">Deterministic vs Sampling Profilers</h3>
<div class="callout-content">
<p>Line-level profiling can be particularly expensive, a program can
execute hundreds of thousands of lines of code per second. Therefore,
collecting information about each line of code can be costly.</p>
<p><code>line_profiler</code> is deterministic, meaning that it tracks
every line of code executed. To avoid it being too costly, the profiling
is restricted to methods targeted with the decorator
<code>@profile</code>.</p>
<p>In contrast, <a href="https://github.com/plasma-umass/scalene" class="external-link"><code>scalene</code></a>
is a more advanced Python profiler capable of line-level profiling. It
uses a sampling based approach, whereby the profiler halts and samples
the line of code currently executing thousands of times per second. This
reduces the cost of profiling, whilst still maintaining representative
metrics for the most expensive components.</p>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="timeline-profiling">Timeline Profiling<a class="anchor" aria-label="anchor" href="#timeline-profiling"></a>
</h3>
<!-- Context -->
<p>Timeline profiling takes a different approach to visualising where
time is being spent during execution.</p>
<!-- What -->
<p>Typically, a subset of function-level profiling, the execution of the
profiled software is instead presented as a timeline highlighting the
order of function execution in addition to the time spent in each
individual function call.</p>
<!-- Why -->
<p>By highlighting individual functions calls, patterns relating to how
performance scales over time can be identified. These would be hidden
with the aforementioned aggregate approaches.</p>
<!-- We will be covering -->
<!-- In this course we will cover the usage of the timeline profiler `viztracer`. -->
<p><a href="https://viztracer.readthedocs.io/en/latest/" class="external-link"><code>viztracer</code></a>
is an example of a timeline profiler for Python, however we won’t be
demonstrating timeline profiling on this course.</p>
<figure><img src="fig/viztracer-example.png" alt="A viztracer timeline of the execution of the Pred-Prey exercise from later in the course. There is a shallow repeating pattern on the left side which corresponds to model steps, the right side instead has a range of 'icicles' which correspond to the deep call hierarchies of matplotlib generating a graph." class="figure mx-auto d-block"><div class="figcaption">An example timeline visualisation provided by
<code>viztracer</code>/<code>vizviewer</code>.</div>
</figure>
</div>
<div class="section level3">
<h3 id="hardware-metric-profiling">Hardware Metric Profiling<a class="anchor" aria-label="anchor" href="#hardware-metric-profiling"></a>
</h3>
<p>Processor manufacturers typically release advanced profilers specific
to their hardware with access to internal hardware metrics. These
profilers can provide analysis of performance relative to theoretical
hardware maximums (e.g. memory bandwidth or operations per second) and
detail the utilisation of specific hardware features and operations.</p>
<p>Using these advanced profilers requires a thorough understanding of
the relevant processor architecture and may lead to hardware specific
optimisations.</p>
<p>Examples of these profilers include; Intel’s VTune, AMD’s uProf, and
NVIDIA’s Nsight Compute.</p>
<p>Profiling of this nature is outside the scope of this course.</p>
</div>
</section><section><h2 class="section-heading" id="selecting-an-appropriate-test-case">Selecting an Appropriate Test Case<a class="anchor" aria-label="anchor" href="#selecting-an-appropriate-test-case"></a>
</h2>
<hr class="half-width">
<!-- Profiling runs slower --><p>The act of profiling your code, collecting additional timing metrics
during execution, will cause your program to execute slower. The
slowdown is dependent on many variables related to both your code and
the granularity of metrics being collected.</p>
<!-- Profiling may generate large amounts of data -->
<p>Similarly, the longer your code runs, the more code that is being
executed, the more data that will be collected. A profile that runs for
hours could produce gigabytes of output data!</p>
<!-- Important to select appropriate test-case/s -->
<p>Therefore, it is important to select an appropriate test-case that is
both representative of a typical workload and small enough that it can
be quickly iterated. Ideally, it should take no more than a few minutes
to run the profiled test-case from start to finish, however you may have
circumstances where something that short is not possible.</p>
<!-- For example -->
<!-- I don't really like this paragraph -->
<p>For example, you may have a model which normally simulates a year in
hourly time-steps. It would be appropriate to begin by profiling the
simulation of a single day. If the model scales over time, such as due
to population growth, it may be pertinent to profile a single day later
into a simulation if the model can be resumed or configured. A larger
population is likely to amplify any bottlenecks that scale with the
population, making them easier to identify.</p>
<div id="exercise-5-minutes" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="exercise-5-minutes" class="callout-inner">
<h3 class="callout-title">Exercise (5 minutes)</h3>
<div class="callout-content">
<p>Think about a project where you’ve been working with Python. Do you
know where the time during execution is being spent?</p>
<p>Write a short plan of the approach you would take to investigate and
confirm where the majority of time is being spent during its
execution.</p>
<!-- TODO should they share this anywhere, should it be discussed within the group? -->
</div>
</div>
</div>
<div id="accordionHint1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button hint-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseHint1" aria-expanded="false" aria-controls="collapseHint1">
  <h4 class="accordion-header" id="headingHint1"> Give me a hint </h4>
</button>
<div id="collapseHint1" class="accordion-collapse collapse" data-bs-parent="#accordionHint1" aria-labelledby="headingHint1">
<div class="accordion-body">
<ul>
<li>What tools and techniques would be required?</li>
<li>Is there a clear priority to these approaches?</li>
<li>Which test-case/s would be appropriate?</li>
</ul>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>Profiling is a relatively quick process to analyse where time is
being spent and bottlenecks during a program’s execution.</li>
<li>Code should be profiled when ready for deployment if it will be
running for more than a few minutes during its lifetime.</li>
<li>There are several types of profiler each with slightly different
purposes.
<ul>
<li>function-level: <code>cProfile</code> (visualised with
<code>snakeviz</code>)</li>
<li>line-level: <code>line_profiler</code>
</li>
<li>timeline: <code>viztracer</code>
</li>
<li>hardware-metric</li>
</ul>
</li>
<li>A representative test-case should be profiled, that is large enough
to amplify any bottlenecks whilst executing to completion quickly.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-profiling-functions"><p>Content from <a href="profiling-functions.html">Function Level Profiling</a></p>
<hr>
<p>Last updated on 2025-05-11 |

        <a href="https://github.com/RSE-Sheffield/pando-python/edit/main/episodes/profiling-functions.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>When is function level profiling appropriate?</li>
<li>How can <code>cProfile</code> and <code>snakeviz</code> be used to
profile a Python program?</li>
<li>How are the outputs from function level profiling interpreted?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>execute a Python program via <code>cProfile</code> to collect
profiling information about a Python program’s execution</li>
<li>use <code>snakeviz</code> to visualise profiling information output
by <code>cProfile</code>
</li>
<li>interpret <code>snakeviz</code> views, to identify the functions
where time is being spent during a program’s execution</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<hr class="half-width">
<!-- TODO Currently it's a verbatim copy from profiling-introduction.md, there's space for more context in this episode.>

<!-- Context --><p>Software is typically comprised of a hierarchy of function calls,
both functions written by the developer and those used from the
language’s standard library and third party packages.</p>
<!-- What -->
<p>Function-level profiling analyses where time is being spent with
respect to functions. Typically function-level profiling will calculate
the number of times each function is called and the total time spent
executing each function, inclusive and exclusive of child function
calls.</p>
<!-- Why -->
<p>This allows functions that occupy a disproportionate amount of the
total runtime to be quickly identified and investigated.</p>
<!-- We will be covering -->
<p>In this episode we will cover the usage of the function-level
profiler <code>cProfile</code>, how it’s output can be visualised with
<code>snakeviz</code> and how the output can be interpreted.</p>
<div id="what-is-a-call-stack" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="what-is-a-call-stack" class="callout-inner">
<h3 class="callout-title">What is a Call Stack?</h3>
<div class="callout-content">
<p>The call stack keeps track of the active hierarchy of function calls
and their associated variables.</p>
<p>As a stack it is a last-in first-out (LIFO) data structure.</p>
<figure><img src="fig/stack.png" alt="A greyscale diagram showing a (call)stack, containing 5 stack frame. Two additional stack frames are shown outside the stack, one is marked as entering the call stack with an arrow labelled push and the other is marked as exiting the call stack labelled pop." class="figure mx-auto d-block"><div class="figcaption">A diagram of a call stack</div>
</figure><p>When a function is called, a frame to track its variables and
metadata is pushed to the call stack. When that same function finishes
and returns, it is popped from the stack and variables local to the
function are dropped.</p>
<p>If you’ve ever seen a stack overflow error, this refers to the call
stack becoming too large. These are typically caused by recursive
algorithms, whereby a function calls itself, that don’t exit early
enough.</p>
<p>Within Python the current call-stack can be printed using the core
<code>traceback</code> package, <code>traceback.print_stack()</code>
will print the current call stack.</p>
<p>The below example:</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">import</span> traceback</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="kw">def</span> a():</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>    b1()</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>    b2()</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="kw">def</span> b1():</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>    <span class="cf">pass</span></span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a><span class="kw">def</span> b2():</span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a>    c()</span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a><span class="kw">def</span> c():</span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a>    traceback.print_stack()</span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a>a()</span></code></pre>
</div>
<p>Here we can see that the printing of the stack trace is called in
<code>c()</code>, which is called by <code>b2()</code>, which is called
by <code>a()</code>, which is called from global scope.</p>
<p>Hence, this prints the following call stack:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>  File "C:\call_stack.py", line 13, in &lt;module&gt;
    a()
  File "C:\call_stack.py", line 5, in a
    b2()
  File "C:\call_stack.py", line 9, in b2
    c()
  File "C:\call_stack.py", line 11, in c
    traceback.print_stack()</code></pre>
</div>
<p>The first line states the file and line number where <code>a()</code>
was called from (the last line of code in the file shown). The second
line states that it was the function <code>a()</code> that was called,
this could include its arguments. The third line then repeats this
pattern, stating the line number where <code>b2()</code> was called
inside <code>a()</code>. This continues until the call to
<code>traceback.print_stack()</code> is reached.</p>
<p>You may see stack traces like this when an unhandled exception is
thrown by your code.</p>
<p><em>In this instance the base of the stack has been printed first,
other visualisations of call stacks may use the reverse
ordering.</em></p>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="cprofile">cProfile<a class="anchor" aria-label="anchor" href="#cprofile"></a>
</h2>
<hr class="half-width">
<!-- What is cProfile/How is it installed --><p><a href="https://docs.python.org/3/library/profile.html#instant-user-s-manual" class="external-link"><code>cProfile</code></a>
is a function-level profiler provided as part of the Python standard
library.</p>
<!-- How is it used? -->
<p>It can be called directly within your Python code as an imported
package, however it’s easier to use its script interface:</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">SH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode sh" tabindex="0"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="ex">python</span> <span class="at">-m</span> cProfile <span class="at">-o</span> <span class="op">&lt;</span>output file<span class="op">&gt;</span> <span class="op">&lt;</span>script name<span class="op">&gt;</span> <span class="op">&lt;</span>arguments<span class="op">&gt;</span></span></code></pre>
</div>
<p>For example if you normally run your program as:</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">SH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode sh" tabindex="0"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="ex">python</span> my_script.py input.csv</span></code></pre>
</div>
<p>You would call <code>cProfile</code> to produce profiling output
<code>out.prof</code> with:</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">SH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode sh" tabindex="0"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="ex">python</span> <span class="at">-m</span> cProfile <span class="at">-o</span> out.prof my_script.py input.csv</span></code></pre>
</div>
<!-- yes it's that simple -->
<p><em>No additional changes to your code are required, it’s really that
simple!</em></p>
<!-- TODO should the remainder of this section be in a call-out, it's unnecessary -->
<p>If you instead, don’t specify output to file (e.g. remove
<code>-o out.prof</code> from the command), <code>cProfile</code> will
produce output to console similar to that shown below:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>         28 function calls in 4.754 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    4.754    4.754 worked_example.py:1(&lt;module&gt;)
        1    0.000    0.000    1.001    1.001 worked_example.py:13(b_2)
        3    0.000    0.000    1.513    0.504 worked_example.py:16(c_1)
        3    0.000    0.000    1.238    0.413 worked_example.py:19(c_2)
        3    0.000    0.000    0.334    0.111 worked_example.py:23(d_1)
        1    0.000    0.000    4.754    4.754 worked_example.py:3(a_1)
        3    0.000    0.000    2.751    0.917 worked_example.py:9(b_1)
        1    0.000    0.000    4.754    4.754 {built-in method builtins.exec}
       11    4.753    0.432    4.753    0.432 {built-in method time.sleep}
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}</code></pre>
</div>
<p>The columns have the following definitions:</p>
<table class="table">
<colgroup>
<col width="15%">
<col width="85%">
</colgroup>
<thead><tr class="header">
<th>Column</th>
<th>Definition</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>ncalls</code></td>
<td>The number of times the given function was called.</td>
</tr>
<tr class="even">
<td><code>tottime</code></td>
<td>The total time spent in the given function, excluding child function
calls.</td>
</tr>
<tr class="odd">
<td><code>percall</code></td>
<td>The average tottime per function call
(<code>tottime</code>/<code>ncalls</code>).</td>
</tr>
<tr class="even">
<td><code>cumtime</code></td>
<td>The total time spent in the given function, including child function
calls.</td>
</tr>
<tr class="odd">
<td><code>percall</code></td>
<td>The average cumtime per function call
(<code>cumtime</code>/<code>ncalls</code>).</td>
</tr>
<tr class="even">
<td><code>filename:lineno(function)</code></td>
<td>The location of the given function’s definition and it’s name.</td>
</tr>
</tbody>
</table>
<p>This output can often exceed the terminal’s buffer length for large
programs and can be unwieldy to parse, so the package
<code>snakeviz</code> is often utilised to provide an interactive
visualisation of the data when exported to file.</p>
</section><section><h2 class="section-heading" id="snakeviz">snakeviz<a class="anchor" aria-label="anchor" href="#snakeviz"></a>
</h2>
<hr class="half-width">
<!-- what is snakeviz/how is it installed--><p><a href="https://jiffyclub.github.io/snakeviz/" class="external-link"><code>snakeviz</code></a>
is a web browser based graphical viewer for <code>cProfile</code> output
files.
<!--TODO is covering pip here redundant as it's covered in the user setup file? -->
It is not part of the Python standard library, and therefore must be
installed via pip.</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">SH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode sh" tabindex="0"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="ex">pip</span> install snakeviz</span></code></pre>
</div>
<p>Once installed, you can visualise a <code>cProfile</code> output file
such as <code>out.prof</code> via:</p>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">SH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode sh" tabindex="0"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="ex">python</span> <span class="at">-m</span> snakeviz out.prof</span></code></pre>
</div>
<p>This should open your web browser displaying a page similar to that
below.</p>
<figure><img src="fig/snakeviz-home.png" alt="A web page, with a central diagram representing a call-stack, with the root at the top and the horizontal axis representing the duration of each call. Below this diagram is the top of a table detailing the statistics of individual methods." class="figure mx-auto d-block"><div class="figcaption">An example of the default ‘icicle’ visualisation
provided by <code>snakeviz</code>.</div>
</figure><!-- From SnakeViz docs
In the icicle visualization style functions are represented by rectangles. A root function is the top-most rectangle, with functions it calls below it, then the functions those call below them, and so on. The amount of time spent inside a function is represented by the width of the rectangle. A rectangle that stretches across most of the visualization represents a function that is taking up most of the time of its calling function, while a skinny rectangle represents a function that is using hardly any time at all.
--><p>The icicle diagram displayed by <code>snakeviz</code> represents an
aggregate of the call stack during the execution of the profiled code.
The box which fills the top row represents the root call, filling the
row shows that it occupied 100% of the runtime. The second row holds the
child methods called from the root, with their widths relative to the
proportion of runtime they occupied. This continues with each subsequent
row, however where a method only occupies 50% of the runtime, its
children can only occupy a maximum of that runtime hence the appearance
of “icicles” as each row gets narrower when the overhead of methods with
no further children is accounted for.</p>
<p>By clicking a box within the diagram, it will “zoom” making the
selected box the root allowing more detail to be explored. The diagram
is limited to 10 rows by default (“Depth”) and methods with a relatively
small proportion of the runtime are hidden (“Cutoff”).</p>
<p>As you hover each box, information to the left of the diagram updates
specifying the location of the method and for how long it ran.</p>
<div id="snakeviz-inside-notebooks" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="snakeviz-inside-notebooks" class="callout-inner">
<h3 class="callout-title">snakeviz Inside Notebooks</h3>
<div class="callout-content">
<p>If you’re more familiar with writing Python inside Jupyter notebooks
you can still use <code>snakeviz</code> directly from inside notebooks
using the notebooks “magic” prefix (<code>%</code>) and it will
automatically call <code>cProfile</code> for you.</p>
<p>First <code>snakeviz</code> must be installed and its extension
loaded.</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PY<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode py" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="op">!</span>pip install snakeviz</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a><span class="op">%</span>load_ext snakeviz</span></code></pre>
</div>
<p>Following this, you can either call <code>%snakeviz</code> to profile
a function defined earlier in the notebook.</p>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PY<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode py" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="op">%</span>snakeviz my_function()</span></code></pre>
</div>
<p>Or, you can create a <code>%%snakeviz</code> cell, to profile the
python executed within it.</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PY<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode py" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="op">%%</span>snakeviz</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a><span class="kw">def</span> my_function():</span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Hello World!"</span>)</span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a>my_function()</span></code></pre>
</div>
<p>In both cases, the full <code>snakeviz</code> profile visualisation
will appear as an output within the notebook!</p>
<p><em>You may wish to right click the top of the output, and select
“Disable Scrolling for Outputs” to expand its box if it begins too
small.</em></p>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="worked-example">Worked Example<a class="anchor" aria-label="anchor" href="#worked-example"></a>
</h2>
<hr class="half-width">
<p>To more clearly demonstrate how an execution hierarchy maps to the
icicle diagram, the below toy example Python script has been
implemented.</p>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a><span class="kw">def</span> a_1():</span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):</span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a>        b_1()</span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a>    time.sleep(<span class="dv">1</span>)</span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a>    b_2()</span>
<span id="cb12-8"><a href="#cb12-8" tabindex="-1"></a>    </span>
<span id="cb12-9"><a href="#cb12-9" tabindex="-1"></a><span class="kw">def</span> b_1():</span>
<span id="cb12-10"><a href="#cb12-10" tabindex="-1"></a>    c_1()</span>
<span id="cb12-11"><a href="#cb12-11" tabindex="-1"></a>    c_2()</span>
<span id="cb12-12"><a href="#cb12-12" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" tabindex="-1"></a><span class="kw">def</span> b_2():</span>
<span id="cb12-14"><a href="#cb12-14" tabindex="-1"></a>    time.sleep(<span class="dv">1</span>)</span>
<span id="cb12-15"><a href="#cb12-15" tabindex="-1"></a>    </span>
<span id="cb12-16"><a href="#cb12-16" tabindex="-1"></a><span class="kw">def</span> c_1():</span>
<span id="cb12-17"><a href="#cb12-17" tabindex="-1"></a>    time.sleep(<span class="fl">0.5</span>)</span>
<span id="cb12-18"><a href="#cb12-18" tabindex="-1"></a></span>
<span id="cb12-19"><a href="#cb12-19" tabindex="-1"></a><span class="kw">def</span> c_2():</span>
<span id="cb12-20"><a href="#cb12-20" tabindex="-1"></a>    time.sleep(<span class="fl">0.3</span>)</span>
<span id="cb12-21"><a href="#cb12-21" tabindex="-1"></a>    d_1()</span>
<span id="cb12-22"><a href="#cb12-22" tabindex="-1"></a></span>
<span id="cb12-23"><a href="#cb12-23" tabindex="-1"></a><span class="kw">def</span> d_1():</span>
<span id="cb12-24"><a href="#cb12-24" tabindex="-1"></a>    time.sleep(<span class="fl">0.1</span>)</span>
<span id="cb12-25"><a href="#cb12-25" tabindex="-1"></a></span>
<span id="cb12-26"><a href="#cb12-26" tabindex="-1"></a><span class="co"># Entry Point</span></span>
<span id="cb12-27"><a href="#cb12-27" tabindex="-1"></a>a_1()</span></code></pre>
</div>
<p>All of the methods except for <code>b_1()</code> call
<code>time.sleep()</code>, this is used to provide synthetic bottlenecks
to create an interesting profile.</p>
<ul>
<li>
<code>a_1()</code> calls <code>b_1()</code> x3 and
<code>b_2()</code> x1</li>
<li>
<code>b_1()</code> calls <code>c_1()</code> x1 and
<code>c_2()</code> x1</li>
<li>
<code>c_2()</code> calls <code>d_1()</code>
</li>
</ul>
<div id="follow-along" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="follow-along" class="callout-inner">
<h3 class="callout-title">Follow Along</h3>
<div class="callout-content">
<p>Download the
<a href="files/snakeviz-worked-example/example.py" download>Python
source for the example</a> or
<a href="files/snakeviz-worked-example/out.prof" download><code>cProfile</code>
output file</a> and follow along with the worked example on your own
machine.</p>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">SH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode sh" tabindex="0"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="ex">python</span> <span class="at">-m</span> cProfile <span class="at">-o</span> out.prof example.py</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a><span class="ex">python</span> <span class="at">-m</span> snakeviz out.prof</span></code></pre>
</div>
</div>
</div>
</div>
<!-- TODO: Alt text here is redundant? -->
<figure><img src="fig/snakeviz-worked-example-icicle.png" alt="The snakeviz icicle visualisation for the worked example Python code." class="figure mx-auto d-block"><div class="figcaption">An icicle visualisation provided by
<code>snakeviz</code> for the above Python code.</div>
</figure><p>The third row represents <code>a_1()</code>, the only method called
from global scope, therefore the first two rows represent Python’s
internal code for launching our script and can be ignored (by clicking
on the third row).</p>
<p>The row following <code>a_1()</code> is split into three boxes
representing <code>b_1()</code>, <code>time.sleep()</code> and
<code>b_2()</code>. Note that <code>b_1()</code> is called three times,
but only has one box within the icicle diagram. The boxes are ordered
left-to-right according to cumulative time, which happens to be the
order they were first called.</p>
<p>If the box for <code>time.sleep()</code> is hovered it will change
colour along with several other boxes that represent the other locations
that <code>time.sleep()</code> was called from. Note that each of these
boxes display the same duration, the timing statistics collected by
<code>cProfile</code> (and visualised by <code>snakeviz</code>) are
aggregate, so there is no information about individual method calls for
methods which were called multiple times. This does however mean that if
you check the properties to the left of the diagram whilst hovering
<code>time.sleep()</code> you will see a cumulative time of 99%
reported, the overhead of the method calls and for loop is insignificant
in contrast to the time spent sleeping!</p>
<p><em>Below are the properties shown, the time may differ if you
generated the profile yourself.</em></p>
<ul>
<li>
<strong>Name:</strong>
<code>&lt;built-in method time.sleep&gt;</code>
</li>
<li>
<strong>Cumulative Time:</strong> <code>4.71 s (99.99 %)</code>
</li>
<li>
<strong>File:</strong> <code>~</code>
</li>
<li>
<strong>Line:</strong> <code>0</code>
</li>
<li><strong>Directory:</strong></li>
</ul>
<p>As <code>time.sleep()</code> is a core Python method it is displayed
as “built-in method” and doesn’t have a file, line or directory.</p>
<p>If you hover any boxes representing the methods from the above code,
you will see file and line properties completed. The directory property
remains empty as the profiled code was in the root of the working
directory. A profile of a large project with many files across multiple
directories will see this filled.</p>
<p>Find the box representing <code>c_2()</code> on the icicle diagram,
its children are unlabelled because they are not wide enough (but they
can still be hovered). Clicking <code>c_2()</code> zooms in the diagram,
showing the children to be <code>time.sleep()</code> and
<code>d_1()</code>.</p>
<p>To zoom back out you can either click the top row, which will zoom
out one layer, or click “Reset Zoom” on the left-hand side.</p>
<p>In this simple example the execution is fairly evenly balanced
between all of the user-defined methods, so there is not a clear
hot-spot to investigate.</p>
<p>Below the icicle diagram, there is a table similar to the default
output from <code>cProfile</code>. However, in this case you can sort
the columns by clicking their headers and filter the rows shown by
entering a filename in the search box. This allows built-in methods to
be hidden, which can make it easier to highlight optimisation
priorities.</p>
<p><strong>Notebooks</strong></p>
<p>If you followed along inside a notebook it might look like this:</p>
<figure><img src="fig/snakeviz-worked-example-notebook.png" style="width:80.0%" alt="A Jupyter notebook showing the worked example profiled with snakeviz." class="figure mx-auto d-block"><div class="figcaption">The worked example inside a notebook.</div>
</figure><p>Because notebooks operate by creating temporary Python files, the
filename (shown <code>1378276351.py</code> above) and line numbers
displayed are not too useful. However, the function names match those
defined in the code and follow the temporary file name in parentheses,
e.g. <code>1378276351.py:3(a_1)</code>,
<code>1378276351.py:9(b_1)</code> refer to the functions
<code>a_1()</code> and <code>b_1()</code> respectively.</p>
<div id="sunburst" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="sunburst" class="callout-inner">
<h3 class="callout-title">Sunburst</h3>
<div class="callout-content">
<p><code>snakeviz</code> provides an alternate “Sunburst” visualisation,
accessed via the “Style” drop-down on the left-hand side.</p>
<p>This provides the same information as “Icicle”, however the rows are
instead circular with the root method call found at the center.</p>
<p>The sunburst visualisation displays less text on the boxes, so it can
be harder to interpret. However, it increases the visibility of boxes
further from the root call.</p>
<!-- TODO: Alt text here is redundant? -->
<figure><img src="fig/snakeviz-worked-example-sunburst.png" style="width:50.0%" alt="A sunburst visualisation for the worked example Python code." class="figure mx-auto d-block"><div class="figcaption">An sunburst visualisation provided by
<code>snakeviz</code> for the worked example’s Python code.</div>
</figure>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="exercises">Exercises<a class="anchor" aria-label="anchor" href="#exercises"></a>
</h2>
<hr class="half-width">
<p>The following exercises allow you to review your understanding of
what has been covered in this episode.</p>

<div id="exercise-1-travelling-salesperson" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="exercise-1-travelling-salesperson" class="callout-inner">
<h3 class="callout-title">Exercise 1: Travelling Salesperson</h3>
<div class="callout-content">
<p>Download and profile
<a href="files/travelling-sales/travellingsales.py" download>this</a>
Python program, try to locate the function call(s) where the majority of
execution time is being spent.</p>
<blockquote>
<p>The travelling salesperson problem aims to optimise the route for a
scenario where a salesperson is requires to travel between N locations.
They wish to travel to each location exactly once, in any order, whilst
minimising the total distance travelled.</p>
<p>The provided implementation uses a naive brute-force approach.</p>
</blockquote>
<p>The program can be executed via
<code>python travellingsales.py &lt;cities&gt;</code>. The value of
<code>cities</code> should be a positive integer, this algorithm has
poor scaling so larger numbers take significantly longer to run.</p>
</div>
</div>
</div>
<div id="accordionHint1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button hint-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseHint1" aria-expanded="false" aria-controls="collapseHint1">
  <h4 class="accordion-header" id="headingHint1"> Give me a hint </h4>
</button>
<div id="collapseHint1" class="accordion-collapse collapse" aria-labelledby="headingHint1" data-bs-parent="#accordionHint1">
<div class="accordion-body">
<ul>
<li>If a hotspot isn’t visible with the argument <code>1</code>, try
increasing the value.</li>
<li>If you think you identified the hotspot with your first profile, try
investigating how the value of <code>cities</code> affects the hotspot
within the profile.</li>
</ul>
</div>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<p>The hotspot only becomes visible when an argument of <code>5</code>
or greater is passed.</p>
<p>You should see that <code>distance()</code> (from
<code>travellingsales.py:11</code>) becomes the largest box (similarly
it’s parent in the call-stack <code>total_distance()</code>) showing
that it scales poorly with the number of cities. With 5 cities,
<code>distance()</code> has a cumulative time of <code>~35%</code> the
runtime, this increases to <code>~60%</code> with 9 cities.</p>
<p>Other boxes within the diagram correspond to the initialisation of
imports, or initialisation of cities. These have constant or linear
scaling, so their cost barely increases with the number of cities.</p>
<p><em>This highlights the need to profile a realistic test-case
expensive enough that initialisation costs are not the most expensive
component.</em></p>
</div>
</div>
</div>
</div>

<div id="exercise-2-predator-prey" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="exercise-2-predator-prey" class="callout-inner">
<h3 class="callout-title">Exercise 2: Predator Prey</h3>
<div class="callout-content">
<p>Download and profile
<a href="files/pred-prey/predprey.py" download>the Python predator prey
model</a>, try to locate the function call(s) where the majority of
execution time is being spent</p>
<p><em>This exercise uses the packages <code>numpy</code> and
<code>matplotlib</code>, they can be installed via
<code>pip install numpy matplotlib</code>.</em></p>
<blockquote>
<p>The predator prey model is a simple agent-based model of population
dynamics. Predators and prey co-exist in a common environment and
compete over finite resources.</p>
<p>The three agents; predators, prey and grass exist in a two
dimensional grid. Predators eat prey, prey eat grass. The size of each
population changes over time. Depending on the parameters of the model,
the populations may oscillate, grow or collapse due to the availability
of their food source.</p>
</blockquote>
<p>The program can be executed via
<code>python predprey.py &lt;steps&gt;</code>. The value of
<code>steps</code> for a full run is 250, however a full run may not be
necessary to find the bottlenecks.</p>
<p>When the model finishes it outputs a graph of the three populations
<code>predprey_out.png</code>.</p>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" aria-labelledby="headingSolution2" data-bs-parent="#accordionSolution2">
<div class="accordion-body">
<p>It should be clear from the profile that the method
<code>Grass::eaten()</code> (from <code>predprey.py:278</code>) occupies
the majority of the runtime.</p>
<p>From the table below the Icicle diagram, we can see that it was
called 1,250,000 times.</p>
<figure><img src="fig/snakeviz-predprey-table.png" alt="The top 9 rows of the table shown by snakeviz when profiling predprey.py. The top row shows that predprey.py:278(eaten) was called 1,250,000 times, taking a total time of 8 seconds. The table is ordered in descending total time, with the next row taking a mere 0.74 seconds." class="figure mx-auto d-block"><div class="figcaption">The top of the table shown by snakeviz.</div>
</figure><p>If the table is ordered by <code>ncalls</code>, it can be identified
as the joint 4th most called method and 2nd most called method from
<code>predprey.py</code>.</p>
<p>If you checked <code>predprey_out.png</code> (shown below), you
should notice that there are significantly more <code>Grass</code>
agents than <code>Predators</code> or <code>Prey</code>.</p>
<figure><img src="fig/predprey_out.png" alt="A line graph plotting population over time through 250 steps of the pred prey model. Grass/20, shown in green, has a brief dip in the first 30 steps, but recovers holding steady at approximately 240 (4800 agents). Prey, shown in blue, starts at 200, quickly drops to around 185, before levelling off for steps and then slowly declining to a final value of 50. The data for predators, shown in red, has significantly more noise. There are 50 predators to begin, this rises briefly before falling to around 10, from here it noisily grows to around 70 by step 250 with several larger declines during the growth." class="figure mx-auto d-block"><div class="figcaption">
<code>predprey_out.png</code> as produced by the
default configuration of <code>predprey.py</code>.</div>
</figure><p>Similarly, the <code>Grass::eaten()</code> has a <code>percall</code>
time is inline with other agent functions such as
<code>Prey::flock()</code> (from <code>predprey.py:67</code>).</p>
<p>Maybe we could investigate this further with line profiling!</p>
<p><em>You may have noticed many iciles on the right hand of the
diagram, these primarily correspond to the <code>import</code> of
<code>matplotlib</code> which is relatively expensive!</em></p>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>A python program can be function level profiled with
<code>cProfile</code> via
<code>python -m cProfile -o &lt;output file&gt; &lt;script name&gt; &lt;arguments&gt;</code>.</li>
<li>The output file from <code>cProfile</code> can be visualised with
<code>snakeviz</code> via
<code>python -m snakeviz &lt;output file&gt;</code>.</li>
<li>Function level profiling output displays the nested call hierarchy,
listing both the cumulative and total minus sub functions time.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-short-break1"><p>Content from <a href="short-break1.html">Break</a></p>
<hr>
<p>Last updated on 2024-03-28 |

        <a href="https://github.com/RSE-Sheffield/pando-python/edit/main/episodes/short-break1.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<p>Take a break. If you can, move around and look at something away from
your screen to give your eyes a rest and a chance to absorb the content
covered so far. <!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 --></p></section><section id="aio-profiling-lines"><p>Content from <a href="profiling-lines.html">Line Level Profiling</a></p>
<hr>
<p>Last updated on 2025-05-11 |

        <a href="https://github.com/RSE-Sheffield/pando-python/edit/main/episodes/profiling-lines.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>When is line level profiling appropriate?</li>
<li>What adjustments are required to Python code to profile with
<code>line_profiler</code>?</li>
<li>How can <code>kernprof</code> be used to profile a Python program?
<!-- Last two overlap somewhat -->
</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>decorate Python code to prepare it for profiling with
<code>line_profiler</code>
</li>
<li>execute a Python program via <code>kernprof</code> to collect
profiling information about a Python program’s execution</li>
<li>interpret output from <code>line_profiler</code>, to identify the
lines where time is being spent during a program’s execution</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<hr class="half-width">
<!-- Context --><p>Whilst profiling, you may find that function-level profiling
highlights expensive methods where you can’t easily determine the cause
of the cost due to their complexity.</p>
<!-- What -->
<p>Line level profiling allows you to target specific methods to collect
more granular metrics, which can help narrow the source of expensive
computation further. Typically, line-level profiling will calculate the
number of times each line is called and the total time spent executing
each line. However, with the increased granularity come increased
collection costs, which is why it’s targeted to specific methods.</p>
<!-- Why -->
<p>This allows lines that occupy a disproportionate amount of the total
runtime to be quickly identified and investigated.</p>
<!-- We will be covering -->
<p>In this episode we will cover the usage of the line-level profiler
<code>line_profiler</code>, how your code should be modified to target
the profiling and how the output can be interpreted.</p>
</section><section><h2 class="section-heading" id="line_profiler">line_profiler<a class="anchor" aria-label="anchor" href="#line_profiler"></a>
</h2>
<hr class="half-width">
<!-- what is line_profiler, how is it installed --><p><a href="https://kernprof.readthedocs.io/en/latest/line_profiler.html#line-profiler-basic-usage" class="external-link"><code>line_profiler</code></a>
is a line-level profiler which provides both text output and
visualisation.</p>
<!--TODO is covering pip here redundant as it's covered in the user setup file? -->
<p>It is not part of the Python standard library, and therefore must be
installed via pip.</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">SH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode sh" tabindex="0"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="ex">pip</span> install line_profiler<span class="pp">[</span><span class="ss">all</span><span class="pp">]</span></span></code></pre>
</div>
<div id="accordionSpoiler1" class="accordion spoiler-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button spoiler-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSpoiler1" aria-expanded="false" aria-controls="collapseSpoiler1">
  <h3 class="accordion-header" id="headingSpoiler1">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="eye"></i></div> Mac OS </h3>
</button>
<div id="collapseSpoiler1" class="accordion-collapse collapse" aria-labelledby="headingSpoiler1" data-bs-parent="#accordionSpoiler1">
<div class="accordion-body">
<p>If you are unable to install <code>line_profiler</code> via
<code>pip</code> on MacOS. Instead it can be installed via
<code>conda</code>.</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">SH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode sh" tabindex="0"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="ex">conda</span> install line_profiler</span></code></pre>
</div>
<p>It may first be necessary to enable conda-forge.</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">SH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode sh" tabindex="0"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="ex">conda</span> config <span class="at">--add</span> channels conda-forge</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<p>To use <code>line_profiler</code> decorate methods to be profiled
with <code>@profile</code> which is imported from
<code>line_profiler</code>.</p>
<p>For example, the below code:</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="kw">def</span> is_prime(number):</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>    <span class="cf">if</span> number <span class="op">&lt;</span> <span class="dv">2</span>:</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, <span class="bu">int</span>(number<span class="op">**</span><span class="fl">0.5</span>) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a>        <span class="cf">if</span> number <span class="op">%</span> i <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a>    </span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a><span class="bu">print</span>(is_prime(<span class="dv">1087</span>))</span></code></pre>
</div>
<p>Would be updated to:</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="im">from</span> line_profiler <span class="im">import</span> profile</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a><span class="at">@profile</span></span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a><span class="kw">def</span> is_prime(number):</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>    <span class="cf">if</span> number <span class="op">&lt;</span> <span class="dv">2</span>:</span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, <span class="bu">int</span>(number<span class="op">**</span><span class="fl">0.5</span>) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a>        <span class="cf">if</span> number <span class="op">%</span> i <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb5-11"><a href="#cb5-11" tabindex="-1"></a>    </span>
<span id="cb5-12"><a href="#cb5-12" tabindex="-1"></a><span class="bu">print</span>(is_prime(<span class="dv">1087</span>))</span></code></pre>
</div>
<p>This tells <code>line_profiler</code> to collect metrics for the
lines within the method <code>is_prime()</code>. You can still execute
your code as normal, and these changes will have no effect.</p>
<p>Similar to the earlier tools, <code>line_profiler</code> can then be
triggered via <code>kernprof</code>.</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">SH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode sh" tabindex="0"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="ex">python</span> <span class="at">-m</span> kernprof <span class="at">-lvr</span> my_script.py</span></code></pre>
</div>
<p>This will output a table per profiled method to console:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Wrote profile results to my_script.py.lprof
Timer unit: 1e-06 s

Total time: 1.65e-05 s
File: my_script.py
Function: is_prime at line 3

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     3                                           @profile
     4                                           def is_prime(number):
     5         1          0.4      0.4      2.4      if number &lt; 2:
     6                                                   return False
     7        32          8.4      0.3     50.9      for i in range(2, int(number**0.5) + 1):
     8        31          7.4      0.2     44.8          if number % i == 0:
     9                                                       return False
    10         1          0.3      0.3      1.8      return True</code></pre>
</div>
<p>The columns have the following definitions:</p>
<table class="table">
<colgroup>
<col width="15%">
<col width="85%">
</colgroup>
<thead><tr class="header">
<th>Column</th>
<th>Definition</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>Line #</code></td>
<td>The line number of the relevant line within the file (specified
above the table).</td>
</tr>
<tr class="even">
<td><code>Hits</code></td>
<td>The total number of times the line was executed.</td>
</tr>
<tr class="odd">
<td><code>Time</code></td>
<td>The total time spent executing that line, including child function
calls.</td>
</tr>
<tr class="even">
<td><code>Per Hit</code></td>
<td>The average time per call, including child function calls
(<code>Time</code>/<code>Hits</code>).</td>
</tr>
<tr class="odd">
<td><code>% Time</code></td>
<td>The time spent executing the line, including child function calls,
relative to the other lines of the function.</td>
</tr>
<tr class="even">
<td><code>Line Contents</code></td>
<td>A copy of the line from the file.</td>
</tr>
</tbody>
</table>
<p>As <code>line_profiler</code> must be attached to specific methods
and cannot attach to a full Python file or project, if your Python file
has significant code in the global scope it will be necessary to move it
into a new method which can then instead be called from global
scope.</p>
<p>The profile is also output to file, in this case
<code>my_script.py.lprof</code>. This file is not human-readable, but
can be printed to console by passing it to <code>line_profiler</code>,
which will then display the same table as above.</p>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">SH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode sh" tabindex="0"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="ex">python</span> <span class="at">-m</span> line_profiler <span class="at">-rm</span> my_script.py.lprof</span></code></pre>
</div>
<!-- TODO line_profiling significantly slows down the profiled methods. Is it possible to dynamically disable/enable profiling with `line_profiler`? kernprof -h implies so, but trial/error and docs is failing me -->
</section><section><h2 class="section-heading" id="worked-example">Worked Example<a class="anchor" aria-label="anchor" href="#worked-example"></a>
</h2>
<hr class="half-width">
<div id="follow-along" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="follow-along" class="callout-inner">
<h3 class="callout-title">Follow Along</h3>
<div class="callout-content">
<p>Download the
<a href="files/line_profiler-worked-example/fizzbuzz.py" download>Python
source for the example</a> and follow along with the worked example on
your own machine.</p>
</div>
</div>
</div>
<p>To more clearly demonstrate how to use <code>line_profiler</code>,
the below implementation of “FizzBuzz” will be line profiled.</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>    <span class="cf">if</span> i <span class="op">%</span> <span class="dv">3</span> <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> i <span class="op">%</span> <span class="dv">5</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"FizzBuzz"</span>)</span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a>    <span class="cf">elif</span> i <span class="op">%</span> <span class="dv">3</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Fizz"</span>)</span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a>    <span class="cf">elif</span> i <span class="op">%</span> <span class="dv">5</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Buzz"</span>)</span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb9-10"><a href="#cb9-10" tabindex="-1"></a>        <span class="bu">print</span>(i)</span></code></pre>
</div>
<p>As there are no methods, firstly it should be updated to move the
code to be profiled into a method:</p>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="kw">def</span> fizzbuzz(n):</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">%</span> <span class="dv">3</span> <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> i <span class="op">%</span> <span class="dv">5</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">"FizzBuzz"</span>)</span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a>        <span class="cf">elif</span> i <span class="op">%</span> <span class="dv">3</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">"Fizz"</span>)</span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a>        <span class="cf">elif</span> i <span class="op">%</span> <span class="dv">5</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">"Buzz"</span>)</span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb10-10"><a href="#cb10-10" tabindex="-1"></a>            <span class="bu">print</span>(i)</span>
<span id="cb10-11"><a href="#cb10-11" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" tabindex="-1"></a>fizzbuzz(<span class="dv">100</span>)</span></code></pre>
</div>
<p>Next the method can be decorated with <code>@profile</code> which
must be imported via <code>line_profiler</code>:</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="im">from</span> line_profiler <span class="im">import</span> profile</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a><span class="at">@profile</span></span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a><span class="kw">def</span> fizzbuzz(n):</span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">%</span> <span class="dv">3</span> <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> i <span class="op">%</span> <span class="dv">5</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">"FizzBuzz"</span>)</span>
<span id="cb11-8"><a href="#cb11-8" tabindex="-1"></a>        <span class="cf">elif</span> i <span class="op">%</span> <span class="dv">3</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb11-9"><a href="#cb11-9" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">"Fizz"</span>)</span>
<span id="cb11-10"><a href="#cb11-10" tabindex="-1"></a>        <span class="cf">elif</span> i <span class="op">%</span> <span class="dv">5</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb11-11"><a href="#cb11-11" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">"Buzz"</span>)</span>
<span id="cb11-12"><a href="#cb11-12" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb11-13"><a href="#cb11-13" tabindex="-1"></a>            <span class="bu">print</span>(i)</span>
<span id="cb11-14"><a href="#cb11-14" tabindex="-1"></a></span>
<span id="cb11-15"><a href="#cb11-15" tabindex="-1"></a>fizzbuzz(<span class="dv">100</span>)</span></code></pre>
</div>
<p>Now that the code has been decorated, it can be profiled!</p>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">SH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode sh" tabindex="0"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="ex">python</span> <span class="at">-m</span> kernprof <span class="at">-lvr</span> fizzbuzz.py</span></code></pre>
</div>
<p>This will output a table per profiled method to console:</p>
<p><em>If you run this locally it should be highlighted due to
<code>-r</code> passed to <code>kernprof</code>.</em></p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Wrote profile results to fizzbuzz.py.lprof
Timer unit: 1e-06 s

Total time: 0.0021535 s
File: fizzbuzz.py
Function: fizzbuzz at line 3

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     3                                           @profile
     4                                           def fizzbuzz(n):
     5       101         32.5      0.3      1.5      for i in range(1, n + 1):
     6       100         26.9      0.3      1.2          if i % 3 == 0 and i % 5 == 0:
     7         6        125.8     21.0      5.8              print("FizzBuzz")
     8        94         16.7      0.2      0.8          elif i % 3 == 0:
     9        27        541.3     20.0     25.1              print("Fizz")
    10        67         12.4      0.2      0.6          elif i % 5 == 0:
    11        14        285.1     20.4     13.2              print("Buzz")
    12                                                   else:
    13        53       1112.8     21.0     51.7              print(i)</code></pre>
</div>
<p>For this basic example, we can calculate that “FizzBuzz” would be
printed 6 times out of 100, and the profile shows that line 7
(<code>print("FizzBuzz")</code>) occupied 5.8% of the runtime. This is
slightly lower than 6% due to the control flow code (printing to console
is expensive relative to the control flow and conditional statements).
Similarly, “Fizz” is printed 27 times and occupies 25.1%, likewise
“Buzz” is printed 14 times and occupies 13.2%. Each print statement has
a similar “Per Hit” time of 20-21 micro seconds.</p>
<p>Therefore it can be seen in this example, how the time spent
executing each line matches expectations.</p>
<div id="rich-output" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="rich-output" class="callout-inner">
<h3 class="callout-title">Rich Output</h3>
<div class="callout-content">
<p>The <code>-r</code> argument passed to <code>kernprof</code> (or
<code>line_profiler</code>) enables rich output, if you run the profile
locally it should look similar to this. <em>This requires the optional
package <code>rich</code>, it will have been installed if
<code>[all]</code> was specified when installing
<code>line_profiler</code> with <code>pip</code>.</em></p>
<figure><img src="fig/line_profiler-worked-example-rich.png" alt="A screenshot of the `line_profiler` output from the previous code block, where the code within the line contents column has basic highlighting." class="figure mx-auto d-block"><div class="figcaption">Rich (highlighted) console output provided by
<code>line_profiler</code> for the above FizzBuzz profile code.</div>
</figure>
</div>
</div>
</div>
<div id="line_profiler-inside-notebooks" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="line_profiler-inside-notebooks" class="callout-inner">
<h3 class="callout-title">line_profiler Inside Notebooks</h3>
<div class="callout-content">
<p>If you’re more familiar with writing Python inside Jupyter notebooks
you can, as with <code>snakeviz</code>, use <code>line_profiler</code>
directly from inside notebooks. However, it is still necessary for the
code you wish to profile to be placed within a function.</p>
<p>First <code>line_profiler</code> must be installed and it’s extension
loaded.</p>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">PY<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode py" tabindex="0"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="op">!</span>pip install line_profiler</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a><span class="op">%</span>load_ext line_profiler</span></code></pre>
</div>
<p>Following this, you call <code>line_profiler</code> with
<code>%lprun</code>.</p>
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">PY<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode py" tabindex="0"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="op">%</span>lprun <span class="op">-</span>f profiled_function_name entry_function_call()</span></code></pre>
</div>
<p>The functions to be line profiled are specified with
<code>-f &lt;function name&gt;</code>, this is repeated for each
individual function that you would otherwise apply the
<code>@profile</code> decorator to.</p>
<p>This is followed by calling the function which runs the full code to
be profiled.</p>
<p>For the above FizzBuzz example it would be:</p>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">PY<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode py" tabindex="0"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="op">%</span>lprun <span class="op">-</span>f fizzbuzz fizzbuzz(<span class="dv">100</span>)</span></code></pre>
</div>
<p>This will then create an output cell with any output from the
profiled code, followed by the standard output from
<code>line_profiler</code>. <em>It is not currently possible to get the
rich/coloured output from <code>line_profiler</code> within
notebooks.</em></p>
<figure><img src="fig/line_profiler-worked-example-notebook.png" alt="A screenshot of the line_profiler output from the previous code block inside a Jupyter notebook." class="figure mx-auto d-block"><div class="figcaption">Output provided by <code>line_profiler</code>
inside a Juypter notebook for the above FizzBuzz profile code.</div>
</figure>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="exercises">Exercises<a class="anchor" aria-label="anchor" href="#exercises"></a>
</h2>
<hr class="half-width">
<p>The following exercises allow you to review your understanding of
what has been covered in this episode.</p>
<div id="exercise-1-bubblesort" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="exercise-1-bubblesort" class="callout-inner">
<h3 class="callout-title">Exercise 1: BubbleSort</h3>
<div class="callout-content">
<p>Download and profile
<a href="files/bubblesort/bubblesort.py" download>the Python bubblesort
implementation</a>, line-level profile the code to investigate where
time is being spent.</p>
<blockquote>
<p>Bubblesort is a basic sorting algorithm, it is not considered to be
efficient so in practice other sorting algorithms are typically
used.</p>
<p>The array to be sorted is iterated, with a pair-wise sort being
applied to each element and it’s neighbour. This can cause elements to
rise (or sink) multiple positions in a single pass, hence the name
bubblesort. This iteration continues until the array is fully iterated
with no elements being swapped.</p>
</blockquote>
<p>The program can be executed via
<code>python bubblesort.py &lt;elements&gt;</code>. The value of
<code>elements</code> should be a positive integer as it represents the
number of elements to be sorted.</p>
</div>
</div>
</div>
<div id="accordionHint1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button hint-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseHint1" aria-expanded="false" aria-controls="collapseHint1">
  <h4 class="accordion-header" id="headingHint1"> Give me a hint </h4>
</button>
<div id="collapseHint1" class="accordion-collapse collapse" aria-labelledby="headingHint1" data-bs-parent="#accordionHint1">
<div class="accordion-body">
<ul>
<li>Remember that the code needs to be moved into a method decorated
with <code>@profile</code>
</li>
<li>This must be imported via
<code>from line_profiler import profile</code>
</li>
<li>100 elements should be suitable for a quick profile</li>
</ul>
</div>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<p>If you chose to profile the whole code, it may look like this:</p>
<div class="codewrapper sourceCode" id="cb17">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb17-3"><a href="#cb17-3" tabindex="-1"></a><span class="im">from</span> line_profiler <span class="im">import</span> profile        <span class="co"># Import profile decorator</span></span>
<span id="cb17-4"><a href="#cb17-4" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" tabindex="-1"></a><span class="at">@profile</span>                                 <span class="co"># Decorate the function to be profiled</span></span>
<span id="cb17-6"><a href="#cb17-6" tabindex="-1"></a><span class="kw">def</span> main():                              <span class="co"># Create a simple function with the code to be profiled</span></span>
<span id="cb17-7"><a href="#cb17-7" tabindex="-1"></a>    <span class="co"># Argument parsing</span></span>
<span id="cb17-8"><a href="#cb17-8" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(sys.argv) <span class="op">!=</span> <span class="dv">2</span>:</span>
<span id="cb17-9"><a href="#cb17-9" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Script expects 1 positive integer argument, </span><span class="sc">%u</span><span class="st"> found."</span><span class="op">%</span>(<span class="bu">len</span>(sys.argv) <span class="op">-</span> <span class="dv">1</span>))</span>
<span id="cb17-10"><a href="#cb17-10" tabindex="-1"></a>        sys.exit()</span>
<span id="cb17-11"><a href="#cb17-11" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">int</span>(sys.argv[<span class="dv">1</span>])</span>
<span id="cb17-12"><a href="#cb17-12" tabindex="-1"></a>    <span class="co"># Init</span></span>
<span id="cb17-13"><a href="#cb17-13" tabindex="-1"></a>    random.seed(<span class="dv">12</span>)</span>
<span id="cb17-14"><a href="#cb17-14" tabindex="-1"></a>    arr <span class="op">=</span> [random.random() <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb17-15"><a href="#cb17-15" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Sorting </span><span class="sc">%d</span><span class="st"> elements"</span><span class="op">%</span>(n))</span>
<span id="cb17-16"><a href="#cb17-16" tabindex="-1"></a>    <span class="co"># Sort</span></span>
<span id="cb17-17"><a href="#cb17-17" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb17-18"><a href="#cb17-18" tabindex="-1"></a>        swapped <span class="op">=</span> <span class="va">False</span></span>
<span id="cb17-19"><a href="#cb17-19" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, n <span class="op">-</span> i <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb17-20"><a href="#cb17-20" tabindex="-1"></a>            <span class="cf">if</span> arr[j] <span class="op">&gt;</span> arr[j <span class="op">+</span> <span class="dv">1</span>]:</span>
<span id="cb17-21"><a href="#cb17-21" tabindex="-1"></a>                arr[j], arr[j <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> arr[j <span class="op">+</span> <span class="dv">1</span>], arr[j]</span>
<span id="cb17-22"><a href="#cb17-22" tabindex="-1"></a>                swapped <span class="op">=</span> <span class="va">True</span></span>
<span id="cb17-23"><a href="#cb17-23" tabindex="-1"></a>        <span class="co"># If no two elements were swapped in the inner loop, the array is sorted</span></span>
<span id="cb17-24"><a href="#cb17-24" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> swapped:</span>
<span id="cb17-25"><a href="#cb17-25" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb17-26"><a href="#cb17-26" tabindex="-1"></a>    <span class="co"># Validate</span></span>
<span id="cb17-27"><a href="#cb17-27" tabindex="-1"></a>    is_sorted <span class="op">=</span> <span class="va">True</span></span>
<span id="cb17-28"><a href="#cb17-28" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb17-29"><a href="#cb17-29" tabindex="-1"></a>        <span class="cf">if</span> arr[i] <span class="op">&gt;</span> arr[i<span class="op">+</span><span class="dv">1</span>]:</span>
<span id="cb17-30"><a href="#cb17-30" tabindex="-1"></a>            is_sorted <span class="op">=</span> <span class="va">False</span></span>
<span id="cb17-31"><a href="#cb17-31" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Sorting: </span><span class="sc">%s</span><span class="st">"</span><span class="op">%</span>(<span class="st">"Passed"</span> <span class="cf">if</span> is_sorted <span class="cf">else</span> <span class="st">"Failed"</span>))</span>
<span id="cb17-32"><a href="#cb17-32" tabindex="-1"></a>    </span>
<span id="cb17-33"><a href="#cb17-33" tabindex="-1"></a>main()                                  <span class="co"># Call the created function</span></span></code></pre>
</div>
<p>The sort can be profiled with 100 elements, this is quick and should
be representative.</p>
<div class="codewrapper sourceCode" id="cb18">
<h3 class="code-label">SH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode sh" tabindex="0"><code class="sourceCode bash"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a><span class="ex">python</span> <span class="at">-m</span> kernprof <span class="at">-lvr</span> bubblesort.py 100</span></code></pre>
</div>
<p>This produces output:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Wrote profile results to bubblesort.py.lprof
Timer unit: 1e-06 s

Total time: 0.002973 s
File: bubblesort.py
Function: main at line 5

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     5                                           @profile
     6                                           def main():
     7                                               # Argument parsing
     8         1          0.7      0.7      0.0      if len(sys.argv) != 2:
     9                                                   print("Script expects 1 positive integer argument, %u found."%…
    10                                                   sys.exit()
    11         1          1.6      1.6      0.1      n = int(sys.argv[1])
    12                                               # Init
    13         1          8.8      8.8      0.3      random.seed(12)
    14         1         16.6     16.6      0.6      arr = [random.random() for i in range(n)]
    15         1         38.2     38.2      1.3      print("Sorting %d elements"%(n))
    16                                               # Sort
    17        95         14.5      0.2      0.5      for i in range(n - 1):
    18        95         13.1      0.1      0.4          swapped = False
    19      5035        723.1      0.1     24.3          for j in range(0, n - i - 1):
    20      4940       1045.9      0.2     35.2              if arr[j] &gt; arr[j + 1]:
    21      2452        686.9      0.3     23.1                  arr[j], arr[j + 1] = arr[j + 1], arr[j]
    22      2452        353.0      0.1     11.9                  swapped = True
    23                                                   # If no two elements were swapped in the inner loop, the array…
    24        95         15.2      0.2      0.5          if not swapped:
    25         1          0.2      0.2      0.0              break
    26                                               # Validate
    27         1          0.5      0.5      0.0      is_sorted = True
    28       100         12.9      0.1      0.4      for i in range(n - 1):
    29        99         20.3      0.2      0.7          if arr[i] &gt; arr[i+1]:
    30                                                       is_sorted = False
    31         1         21.5     21.5      0.7      print("Sorting: %s"%("Passed" if is_sorted else "Failed"))</code></pre>
</div>
<p>From this we can identify that the print statements were the most
expensive individual calls (“Per Hit”), however both were only called
once. Most execution time was spent at the inner loop (lines 19-22).</p>
<p>As this is a reference implementation of a classic sorting algorithm
we are unlikely to be able to improve it further.</p>
</div>
</div>
</div>
</div>

<div id="exercise-2-predator-prey" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="exercise-2-predator-prey" class="callout-inner">
<h3 class="callout-title">Exercise 2: Predator Prey</h3>
<div class="callout-content">
<p>During the function-level profiling episode,
<a href="files/pred-prey/predprey.py" download>the Python predator prey
model</a> was function-level profiled. This highlighted that
<code>Grass::eaten()</code> (from <code>predprey.py:278</code>) occupies
the majority of the runtime.</p>
<p>Line-profile this method, using the output from the profile consider
how it might be optimised.</p>
</div>
</div>
</div>
<div id="accordionHint2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button hint-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseHint2" aria-expanded="false" aria-controls="collapseHint2">
  <h4 class="accordion-header" id="headingHint2"> Give me a hint </h4>
</button>
<div id="collapseHint2" class="accordion-collapse collapse" aria-labelledby="headingHint2" data-bs-parent="#accordionHint2">
<div class="accordion-body">
<ul>
<li>Remember that the function needs to be decorated with
<code>@profile</code>
</li>
<li>This must be imported via
<code>from line_profiler import profile</code>
</li>
<li>Line-level profiling <code>Grass::eaten()</code>, the most called
function will slow it down significantly. You may wish to reduce the
number of steps <code>predprey.py:305</code>.</li>
</ul>
</div>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" aria-labelledby="headingSolution2" data-bs-parent="#accordionSolution2">
<div class="accordion-body">
<p>First the function must be decorated</p>
<div class="codewrapper sourceCode" id="cb21">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a><span class="co"># line ~1</span></span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a><span class="im">from</span> line_profiler <span class="im">import</span> profile</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb22">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a><span class="co"># line ~278</span></span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a>    <span class="at">@profile</span></span>
<span id="cb22-3"><a href="#cb22-3" tabindex="-1"></a>    <span class="kw">def</span> eaten(<span class="va">self</span>, prey_list):</span></code></pre>
</div>
<p><code>line_profiler</code> can then be executed via
<code>python -m kernprof -lvr predprey.py &lt;steps&gt;</code>.</p>
<p>Since this will take much longer to run due to
<code>line_profiler</code>, you may wish to profile fewer
<code>steps</code> than you did in the function-level profiling exercise
(250 was suggested for a full run). In this instance it may change the
profiling output slightly, as the number of <code>Prey</code> and their
member variables evaluated by this method both change as the model
progresses, but the overall pattern is likely to remain similar.</p>
<p>Alternatively, you can kill the profiling process
(e.g. <code>ctrl + c</code>) after a minute and the currently collected
partial profiling information will be output.</p>
<p>This will produce output similar to that below.</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Wrote profile results to predprey.py.lprof
Timer unit: 1e-06 s

Total time: 101.573 s
File: predprey.py
Function: eaten at line 278

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   278                                               @profile
   279                                               def eaten(self, prey_list):
   280   1250000     227663.1      0.2      0.2          if self.available:
   281   1201630     165896.4      0.1      0.2              prey_index = -1
   282   1201630     166219.0      0.1      0.2              closest_prey = GRASS_EAT_DISTANCE
   283
   284                                                       # Iterate prey_location messages to find the closest prey
   285 198235791   29227902.1      0.1     28.8              for i in range(len(prey_list)):
   286 197034161   30158318.8      0.2     29.7                  prey = prey_list[i]
   287 197034161   38781451.1      0.2     38.2                  if prey.life &lt; PREY_HUNGER_THRESH:
   288                                                               # Check if they are within interaction radius
   289   2969470     579923.4      0.2      0.6                      dx = self.x - prey.x
   290   2969470     552092.2      0.2      0.5                      dy = self.y - prey.y
   291   2969470     938669.8      0.3      0.9                      distance = math.sqrt(dx*dx + dy*dy)
   292
   293   2969470     552853.8      0.2      0.5                      if distance &lt; closest_prey:
   294      2532        469.3      0.2      0.0                          prey_index = i
   295      2532        430.1      0.2      0.0                          closest_prey = distance
   296
   297   1201630     217534.5      0.2      0.2              if prey_index &gt;= 0:
   298                                                           # Add grass eaten message
   299      2497       2181.8      0.9      0.0                  prey_list[prey_index].life += GAIN_FROM_FOOD_PREY
   300
   301                                                           # Update grass agent variables
   302      2497        793.9      0.3      0.0                  self.dead_cycles = 0
   303      2497        631.0      0.3      0.0                  self.available = 0</code></pre>
</div>
<p>From the profiling output it can be seen that lines 285-287 occupy
over 90% of the method’s runtime!</p>
<div class="codewrapper sourceCode" id="cb24">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(prey_list)):</span>
<span id="cb24-2"><a href="#cb24-2" tabindex="-1"></a>                prey <span class="op">=</span> prey_list[i]</span>
<span id="cb24-3"><a href="#cb24-3" tabindex="-1"></a>                <span class="cf">if</span> prey.life <span class="op">&lt;</span> PREY_HUNGER_THRESH:</span></code></pre>
</div>
<p>Given that the following line 289 only has a relative 0.6% time, it
can be understood that the vast majority of times the condition
<code>prey.life &lt; PREY_HUNGER_THRESH</code> is evaluated it does not
proceed.</p>
<p>Remembering that this method is executed once per each of the 5000
<code>Grass</code> agents each step of the model, it could make sense to
pre-filter <code>prey_list</code> once each time-step before it is
passed to <code>Grass::eaten()</code>. This would greatly reduce the
number of <code>Prey</code> iterated, reducing the cost of the
method.</p>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>Specific methods can be line-level profiled if decorated with
<code>@profile</code> that is imported from
<code>line_profiler</code>.</li>
<li>
<code>kernprof</code> executes <code>line_profiler</code> via
<code>python -m kernprof -lvr &lt;script name&gt; &lt;arguments&gt;</code>.</li>
<li>Code in global scope must be wrapped in a method if it is to be
profiled with <code>line_profiler</code>.</li>
<li>The output from <code>line_profiler</code> lists the absolute and
relative time spent per line for each targeted function.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-profiling-conclusion"><p>Content from <a href="profiling-conclusion.html">Profiling Conclusion</a></p>
<hr>
<p>Last updated on 2024-03-28 |

        <a href="https://github.com/RSE-Sheffield/pando-python/edit/main/episodes/profiling-conclusion.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What has been learnt about profiling?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Review what has been learnt about profiling</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<p>This concludes the profiling portion of the course.</p>
<p><code>cProfile</code>, <code>snakeviz</code> and
<code>line_profiler</code> have been introduced, these are some of the
most accessible Python profiling tools.</p>
<p>With these transferable skills, if necessary, you should be able to
follow documentation to use more advanced Python profiling tools such as
<a href="https://github.com/plasma-umass/scalene" class="external-link"><code>scalene</code></a>.</p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<p>What profiling is:</p>
<ul>
<li>The collection and analysis of metrics relating to the performance
of a program during execution .</li>
</ul>
<p>Why programmers can benefit from profiling:</p>
<ul>
<li>Narrows down the costly areas of code, allowing optimisation to be
prioritised or decided to be unnecessary.</li>
</ul>
<p>When to Profile:</p>
<ul>
<li>Profiling should be performed on functional code, either when
concerned about performance or prior to release/deployment.</li>
</ul>
<p>What to Profile:</p>
<ul>
<li>The collection of profiling metrics will often slow the execution of
code, therefore the test-case should be narrow whilst remaining
representative of a realistic run.</li>
</ul>
<p>How to function-level profile:</p>
<ul>
<li>Execute <code>cProfile</code> via
<code>python -m cProfile -o &lt;output file&gt; &lt;script name&gt; &lt;arguments&gt;</code>
</li>
<li>Execute <code>snakeviz</code> via
<code>python -m snakeviz &lt;output file&gt;</code>
</li>
</ul>
<p>How to line-level profile:</p>
<ul>
<li>Import <code>profile</code> from <code>line_profiling</code>
</li>
<li>Decorate targeted methods with <code>@profile</code>
</li>
<li>Execute <code>line_profiler</code> via
<code>python -m kernprof -lvr &lt;script name&gt; &lt;arguments&gt;</code>
</li>
</ul>
</div>
</div>
</div></section><section id="aio-optimisation-introduction"><p>Content from <a href="optimisation-introduction.html">Introduction to Optimisation</a></p>
<hr>
<p>Last updated on 2025-03-26 |

        <a href="https://github.com/RSE-Sheffield/pando-python/edit/main/episodes/optimisation-introduction.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>Why could optimisation of code be harmful?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Able to explain the cost benefit analysis of performing code
optimisation</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<hr class="half-width">
<!-- Enable you to look at hotspots identified by compiler, identify whether it's efficient --><p>Now that you’re able to find the most expensive components of your
code with profiling, we can think about ways to improve it. However, the
best way to do this will depend a lot on your specific code! For
example, if your code is spending 60 seconds waiting to download data
files and then 1 second to analyse that data, then optimizing your data
analysis code won’t make much of a difference. We’ll talk briefly about
some of these external bottlenecks at the end. For now, we’ll assume
that you’re not waiting for anything else and we’ll look at the
performance of your code.</p>
<!-- Necessary to understand how code executes (to a degree) -->
<p>In order to optimise code for performance, it is necessary to have an
understanding of what a computer is doing to execute it.</p>
<!-- Goal is to give you a high level understanding of how your code executes. You don't need to be an expert, even a vague general understanding will leave you in a stronger position. -->
<p>A high-level understanding of how your code executes, such as how
Python and the most common data-structures and algorithms are
implemented, can help you identify suboptimal approaches when
programming. If you have learned to write code informally out of
necessity, to get something to work, it’s not uncommon to have collected
some “unpythonic” habits along the way that may harm your code’s
performance.</p>
<!-- This should be considered good practice that you can implement when first writing your code. -->
<p>These are the first steps in code optimisation, and knowledge you can
put into practice by making more informed choices as you write your code
and after profiling it.</p>
<!-- This is largely high-level/abstract knowledge applicable to the vast majority of programming languages, applies even more strongly if using compiled Python features like numba -->
<p>The remaining content is often abstract knowledge, that is
transferable to the vast majority of programming languages. This is
because the hardware architecture, data-structures and algorithms used
are common to many languages and they hold some of the greatest
influence over performance bottlenecks.</p>
</section><section><h2 class="section-heading" id="performance-vs-maintainability">Performance vs Maintainability<a class="anchor" aria-label="anchor" href="#performance-vs-maintainability"></a>
</h2>
<hr class="half-width">
<blockquote>
<p>Programmers waste enormous amounts of time thinking about, or
worrying about, the speed of noncritical parts of their programs, and
these attempts at efficiency actually have a strong negative impact when
debugging and maintenance are considered. We should forget about small
efficiencies, say about 97% of the time: <strong>premature optimization
is the root of all evil</strong>. Yet we should not pass up our
opportunities in that critical 3%. - Donald Knuth</p>
</blockquote>
<p>This classic quote among computer scientists emphasises the
importance of considering both performance and maintainability when
optimising code and prioritising your optimisations.</p>
<p>While advanced optimisations may boost performance, they often come
at the cost of making the code harder to understand and maintain. Even
if you’re working alone on private code, your future self should be able
to easily understand the implementation. Hence, when optimising, always
weigh the potential impact on both performance and maintainability.
While this course does not cover most advanced optimisations, you may
already be familiar with and using some.</p>
<p>Profiling is a valuable tool for prioritising optimisations. Should
effort be expended to optimise a component which occupies 1% of the
runtime? Or would that time be better spent optimising the most
expensive components?</p>
<p>This doesn’t mean you should ignore performance when initially
writing code. Choosing the right algorithms and data structures, as we
will discuss in this course, is good practice. However, there’s no need
to obsess over micro-optimising every tiny component of your code—focus
on the bigger picture.</p>
</section><section><h2 class="section-heading" id="performance-of-python">Performance of Python<a class="anchor" aria-label="anchor" href="#performance-of-python"></a>
</h2>
<hr class="half-width">
<p>If you’ve read about different programming languages, you may have
heard that there’s a difference between “interpreted” languages (like
Python) and “compiled” languages (like C). You may have heard that
Python is slow <em>because</em> it is an interpreted language. To
understand where this comes from (and how to get around it), let’s talk
a little bit about how Python works.</p>
<figure><img src="fig/int-c-vs-py.png" alt="A diagram illustrating the difference between integers in C and Python. In C, the integer is a raw number in memory. In Python, it additionally contains a header with metadata." class="figure mx-auto d-block"><!-- Figure inspired by https://jakevdp.github.io/blog/2014/05/09/why-python-is-slow/#1.-Python-is-Dynamically-Typed-rather-than-Statically-Typed. --></figure><p>In C, integers (or other basic types) are raw data in memory. It is
up to the programmer to keep track of the data type. The compiler can
then turn the source code directly into machine code. This allows the
compiler to perform low-level optimisations that better exploit hardware
nuance to achieve fast performance. This however comes at the cost of
compiled software not being cross-platform.</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">C<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode c" tabindex="0"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="co">/* C code */</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="dt">int</span> a <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="dt">int</span> b <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="dt">int</span> c <span class="op">=</span> a <span class="op">+</span> b<span class="op">;</span></span></code></pre>
</div>
<p>In Python, everything is a complex object. The interpreter uses extra
fields in the header to keep track of data types at runtime or take care
of memory management. This adds a lot more flexibility and makes life
easier for programmers. However, it comes at the cost of some overhead
in both time and memory usage.</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="co"># Python code</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>a <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>b <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a>c <span class="op">=</span> a <span class="op">+</span> b</span></code></pre>
</div>
<div id="callout1" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Callout</h3>
<div class="callout-content">
<p>Objects store both their raw data (like an integer or string) and
some internal information used by the interpreter. We can see that
additional storage space with <code>sys.getsizeof()</code>, which shows
how many bytes an object takes up:</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>sys.getsizeof(<span class="st">""</span>)  <span class="co"># 41</span></span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>sys.getsizeof(<span class="st">"a"</span>)  <span class="co"># 42</span></span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>sys.getsizeof(<span class="st">"ab"</span>)  <span class="co"># 43</span></span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>sys.getsizeof([])  <span class="co"># 56</span></span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a>sys.getsizeof([<span class="st">"a"</span>])  <span class="co"># 64</span></span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a>sys.getsizeof(<span class="dv">1</span>)  <span class="co"># 28</span></span></code></pre>
</div>
<p>(Note: For container objects (like lists and dictionaries) or custom
classes, values returned by <code>getsizeof()</code> are
implementation-dependent and may not reflect the actual memory
usage.)</p>
</div>
</div>
</div>
<p>We effectively gain programmer performance by sacrificing some code
performance. Most of the time, computers are “fast enough” so this is
the right trade-off, as Donald Knuth said.</p>
<p>However, there are the few other cases where code performance really
matters. To handle these cases, Python has the capability to integrate
with code written in lower-level programming language (like C, Fortran
or Rust) under the hood. Some performance-sensitive libraries therefore
perform a lot of the work in such low-level code, before returning a
nice Python object back to you. (We’ll discuss NumPy in a later section;
but many parts of the Python standard library also use this
pattern.)</p>
<p>Therefore, <strong>it is often best to tell the interpreter/library
at a high level <em>what you want</em>, and let it figure out <em>how to
do it</em>.</strong></p>
<p>That way, the interpreter/library is free to do all its work in the
low-level code, and adds overhead only once, when it creates and returns
a Python object in the end. This usually makes your code more readable,
too: When someone else reads your code, they can see exactly <em>what
you want to do</em>, without getting overwhelmed by overly detailed
step-by-step instructions.</p>
</section><section><h2 class="section-heading" id="ensuring-reproducible-results">Ensuring Reproducible Results<a class="anchor" aria-label="anchor" href="#ensuring-reproducible-results"></a>
</h2>
<hr class="half-width">
<!-- This is also good practice when optimising your code, to ensure mistakes aren't made --><p>When optimising existing code, you’re often making speculative
changes, which can lead to subtle mistakes. To ensure that your
optimisations aren’t also introducing errors, it’s crucial to have a
strategy for checking that the results remain correct.</p>
<p>Testing should already be an integral part of your development
process. It helps clarify expected behaviour, ensures new features are
working as intended, and protects against unintended regressions in
previously working functionality. Always verify your changes through
testing to ensure that the optimisations don’t compromise the
correctness of your code.</p>
</section><section><h2 class="section-heading" id="pytest-overview">pytest Overview<a class="anchor" aria-label="anchor" href="#pytest-overview"></a>
</h2>
<hr class="half-width">
<p>There are a plethora of methods for testing code. Most Python
developers use the testing package <a href="https://docs.pytest.org/en/latest/" class="external-link">pytest</a>, it’s a great place
to get started if you’re new to testing code.</p>
<p>Here’s a quick example of how a test can be used to check your
function’s output against an expected value.</p>
<p>Tests should be created within a project’s testing directory, by
creating files named with the form <code>test_*.py</code> or
<code>*_test.py</code>. pytest looks for file names with these patterns
when running the test suite.</p>
<p>Within the created test file, any functions named in the form
<code>test*</code> are considered tests that will be executed by
pytest.</p>
<p>The <code>assert</code> keyword is used, to test whether a condition
evaluates to <code>True</code>.</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="co"># file: test_demonstration.py</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a><span class="co"># A simple function to be tested, this could instead be an imported package</span></span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a><span class="kw">def</span> squared(x):</span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a>    <span class="cf">return</span> x<span class="op">**</span><span class="dv">2</span></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a><span class="co"># A simple test case</span></span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a><span class="kw">def</span> test_example():</span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a>    <span class="cf">assert</span> squared(<span class="dv">5</span>) <span class="op">==</span> <span class="dv">24</span></span></code></pre>
</div>
<p>When <code>py.test</code> is called inside a working directory, it
will then recursively find and execute all the available tests.</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">SH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode sh" tabindex="0"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="op">&gt;</span>py.test</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a><span class="ex">=================================================</span> test session starts =================================================</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a><span class="ex">platform</span> win32 <span class="at">--</span> Python 3.10.12, pytest-7.3.1, pluggy-1.3.0</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a><span class="ex">rootdir:</span> C:<span class="dt">\d</span>emo</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a><span class="ex">plugins:</span> anyio-4.0.0, cov-4.1.0, xdoctest-1.1.2</span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a><span class="ex">collected</span> 1 item</span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a><span class="ex">test_demonstration.py</span> F                                                                                          <span class="pp">[</span><span class="ss">100%</span><span class="pp">]</span></span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a><span class="ex">======================================================</span> FAILURES =======================================================</span>
<span id="cb5-11"><a href="#cb5-11" tabindex="-1"></a><span class="ex">____________________________________________________</span> test_example _____________________________________________________</span>
<span id="cb5-12"><a href="#cb5-12" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" tabindex="-1"></a>    <span class="ex">def</span> test_example<span class="er">(</span><span class="kw">)</span><span class="bu">:</span></span>
<span id="cb5-14"><a href="#cb5-14" tabindex="-1"></a><span class="op">&gt;</span>       assert <span class="ex">squared</span><span class="er">(</span><span class="ex">5</span><span class="kw">)</span> <span class="ex">==</span> 24</span>
<span id="cb5-15"><a href="#cb5-15" tabindex="-1"></a><span class="ex">E</span>       assert 25 == 24</span>
<span id="cb5-16"><a href="#cb5-16" tabindex="-1"></a><span class="ex">E</span>        +  where 25 = squared<span class="er">(</span><span class="ex">5</span><span class="kw">)</span></span>
<span id="cb5-17"><a href="#cb5-17" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" tabindex="-1"></a><span class="ex">test_demonstration.py:9:</span> AssertionError</span>
<span id="cb5-19"><a href="#cb5-19" tabindex="-1"></a><span class="ex">===============================================</span> short test summary info ===============================================</span>
<span id="cb5-20"><a href="#cb5-20" tabindex="-1"></a><span class="ex">FAILED</span> test_demonstration.py::test_example <span class="at">-</span> assert 25 == 24</span>
<span id="cb5-21"><a href="#cb5-21" tabindex="-1"></a><span class="ex">==================================================</span> 1 failed in 0.07s ==================================================</span></code></pre>
</div>
<p>Whilst not designed for benchmarking, it does provide the total time
the test suite took to execute. In some cases this may help identify
whether the optimisations have had a significant impact on
performance.</p>
<p>This is only the simplest introduction to using pytest, it has
advanced features common to other testing frameworks such as fixtures,
mocking and test skipping. <a href="https://docs.pytest.org/en/latest/how-to/index.html" class="external-link">pytest’s
documentation</a> covers all this and more. You may already have a
different testing workflow in-place for validating the correctness of
the outputs from your code.</p>

<!-- todo callout FAIR: testing course (when it's ready) -->
<!--
## Coming Up

In the remainder of this course we will cover:

- Data Structures & Algorithms
  - Lists vs Tuples
  - Sets
  - Generator Functions
  - Searching
- Minimise Python Written
    - built-ins
    - NumPY
    - Pandas
- Newer is Often Faster
  - Keeping Python and packages upto date
- How the Computer Hardware Affects Performance
   - How variables are accessed & the performance implications
   - Latency in perspective
   - Memory allocation isn't free
-->
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>The knowledge necessary to perform high-level optimisations of code
is largely transferable between programming languages.</li>
<li>When considering optimisation it is important to focus on the
potential impact, both to the performance and maintainability of the
code.</li>
<li>Many high-level optimisations should be considered
good-practice.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-optimisation-using-python"><p>Content from <a href="optimisation-using-python.html">Using Python Language Features and the Standard Library</a></p>
<hr>
<p>Last updated on 2025-05-11 |

        <a href="https://github.com/RSE-Sheffield/pando-python/edit/main/episodes/optimisation-using-python.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>Why are Python loops slower than specialised functions?</li>
<li>How can I make my code more readable and faster?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Able to utilise Python language features effectively</li>
<li>Able to search Python documentation for functionality available in
built-in types and in the standard library</li>
<li>Able to identify when Python code can be rewritten to perform
execution in the back-end.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<p>Before we look at data structures, algorithms and third-party
libraries, it’s worth reviewing the fundamentals of Python. If you’re
familiar with other programming languages, like C or Delphi, you might
not know the Pythonic approaches. Whilst you can write Python in a way
similar to other languages, it is often more effective to take advantage
of Python’s principles and idioms.</p>
<section><h2 class="section-heading" id="built-in-functions">Built-in Functions<a class="anchor" aria-label="anchor" href="#built-in-functions"></a>
</h2>
<hr class="half-width">
<p>For example, you might think to sum a list of numbers by using a for
loop, as would be typical in C, as shown in the function
<code>manualSumC()</code> and <code>manualSumPy()</code> below.</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="im">from</span> timeit <span class="im">import</span> timeit</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">100000</span>  <span class="co"># Number of elements in the list</span></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="co"># Ensure every list is the same</span></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>random.seed(<span class="dv">12</span>)</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>my_data <span class="op">=</span> [random.random() <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N)]</span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a><span class="kw">def</span> manualSumC():</span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a>    n <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(my_data)):</span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a>        n <span class="op">+=</span> my_data[i]</span>
<span id="cb1-15"><a href="#cb1-15" tabindex="-1"></a>    <span class="cf">return</span> n</span>
<span id="cb1-16"><a href="#cb1-16" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" tabindex="-1"></a><span class="kw">def</span> manualSumPy(): </span>
<span id="cb1-18"><a href="#cb1-18" tabindex="-1"></a>    n <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb1-19"><a href="#cb1-19" tabindex="-1"></a>    <span class="cf">for</span> evt_count <span class="kw">in</span> my_data:</span>
<span id="cb1-20"><a href="#cb1-20" tabindex="-1"></a>        n <span class="op">+=</span> evt_count</span>
<span id="cb1-21"><a href="#cb1-21" tabindex="-1"></a>    <span class="cf">return</span> n</span>
<span id="cb1-22"><a href="#cb1-22" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" tabindex="-1"></a><span class="kw">def</span> builtinSum(): </span>
<span id="cb1-24"><a href="#cb1-24" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sum</span>(my_data)</span>
<span id="cb1-25"><a href="#cb1-25" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" tabindex="-1"></a>repeats <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb1-28"><a href="#cb1-28" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"manualSumC: </span><span class="sc">{</span>timeit(manualSumC, <span class="bu">globals</span><span class="op">=</span><span class="bu">globals</span>(), number<span class="op">=</span>repeats)<span class="sc">:.3f}</span><span class="ss">ms"</span>)</span>
<span id="cb1-29"><a href="#cb1-29" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"manualSumPy: </span><span class="sc">{</span>timeit(manualSumPy, <span class="bu">globals</span><span class="op">=</span><span class="bu">globals</span>(), number<span class="op">=</span>repeats)<span class="sc">:.3f}</span><span class="ss">ms"</span>)</span>
<span id="cb1-30"><a href="#cb1-30" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"builtinSum: </span><span class="sc">{</span>timeit(builtinSum, <span class="bu">globals</span><span class="op">=</span><span class="bu">globals</span>(), number<span class="op">=</span>repeats)<span class="sc">:.3f}</span><span class="ss">ms"</span>)</span></code></pre>
</div>
<p>Even just replacing the iteration over indices (which may be a habit
you’ve picked up if you first learned to program in C) with a more
pythonic iteration over the elements themselves speeds up the code by
about 2x. But even better, by switching to the built-in
<code>sum()</code> function our code becomes about 8x faster and much
easier to read while doing the exact same operation!</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>manualSumC: 1.624ms
manualSumPy: 0.740ms
builtinSum: 0.218ms</code></pre>
</div>
<p>This is because <a href="https://docs.python.org/3/library/functions.html" class="external-link">built-in
functions</a> (i.e. those that are available without importing packages)
are typically implemented in the CPython back-end, so their performance
benefits from bypassing the Python interpreter.</p>
<p>In particular, those which are passed an <code>iterable</code>
(e.g. lists) are likely to provide the greatest benefits to performance.
The Python documentation provides equivalent Python code for many of
these cases.</p>
<ul>
<li>
<a href="https://docs.python.org/3/library/functions.html#all" class="external-link"><code>all()</code></a>:
boolean and of all items</li>
<li>
<a href="https://docs.python.org/3/library/functions.html#all" class="external-link"><code>any()</code></a>:
boolean or of all items</li>
<li>
<a href="https://docs.python.org/3/library/functions.html#max" class="external-link"><code>max()</code></a>:
Return the maximum item</li>
<li>
<a href="https://docs.python.org/3/library/functions.html#min" class="external-link"><code>min()</code></a>:
Return the minimum item</li>
<li>
<a href="https://docs.python.org/3/library/functions.html#sum" class="external-link"><code>sum()</code></a>:
Return the sum of all items</li>
</ul>
<!-- todo exercise/s where pure-python must be converted to use one of the above fns. --><div id="callout1" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Callout</h3>
<div class="callout-content">
<p>The built-in functions <a href="https://docs.python.org/3/library/functions.html#filter" class="external-link"><code>filter()</code></a>
and <a href="https://docs.python.org/3/library/functions.html#map" class="external-link"><code>map()</code></a>
can be used for processing iterables. However, list-comprehension is
likely to be more performant.</p>
<!-- Would this benefit from an example? -->
</div>
</div>
</div>
<p>This is a nice illustration of the principle we discussed earlier: It
is often best to tell the interpreter/library at a high level <em>what
you want</em>, and let it figure out <em>how to do it</em>.</p>
</section><section><h2 class="section-heading" id="example-searching-an-element-in-a-list">Example: Searching an element in a list<a class="anchor" aria-label="anchor" href="#example-searching-an-element-in-a-list"></a>
</h2>
<hr class="half-width">
<p>A simple example of this is performing a linear search on a list.
(Though as we’ll see in the next section, this isn’t the most efficient
approach!) In the following example, we create a list of 2500 integers
in the (inclusive-exclusive) range <code>[0, 5000)</code>. The goal is
to search for all even numbers within that range.</p>
<p>The function <code>manualSearch()</code> manually iterates through
the list (<code>ls</code>) and checks each individual item using Python
code. On the other hand, <code>operatorSearch()</code> uses the
<code>in</code> operator to perform each search, which allows CPython to
implement the inner loop in its C back-end.</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">2500</span>  <span class="co"># Number of elements in list</span></span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>M <span class="op">=</span> <span class="dv">2</span>  <span class="co"># N*M == Range over which the elements span</span></span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a><span class="kw">def</span> generateInputs():</span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>    random.seed(<span class="dv">12</span>)  <span class="co"># Ensure every list is the same</span></span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a>    <span class="cf">return</span> [random.randint(<span class="dv">0</span>, <span class="bu">int</span>(N<span class="op">*</span>M)) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N)]</span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a>    </span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a><span class="kw">def</span> manualSearch():</span>
<span id="cb3-11"><a href="#cb3-11" tabindex="-1"></a>    ls <span class="op">=</span> generateInputs()</span>
<span id="cb3-12"><a href="#cb3-12" tabindex="-1"></a>    ct <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-13"><a href="#cb3-13" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">int</span>(N<span class="op">*</span>M), M):</span>
<span id="cb3-14"><a href="#cb3-14" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(ls)):</span>
<span id="cb3-15"><a href="#cb3-15" tabindex="-1"></a>            <span class="cf">if</span> ls[j] <span class="op">==</span> i:</span>
<span id="cb3-16"><a href="#cb3-16" tabindex="-1"></a>                ct <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-17"><a href="#cb3-17" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb3-18"><a href="#cb3-18" tabindex="-1"></a></span>
<span id="cb3-19"><a href="#cb3-19" tabindex="-1"></a><span class="kw">def</span> operatorSearch():</span>
<span id="cb3-20"><a href="#cb3-20" tabindex="-1"></a>    ls <span class="op">=</span> generateInputs()</span>
<span id="cb3-21"><a href="#cb3-21" tabindex="-1"></a>    ct <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-22"><a href="#cb3-22" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">int</span>(N<span class="op">*</span>M), M):</span>
<span id="cb3-23"><a href="#cb3-23" tabindex="-1"></a>        <span class="cf">if</span> i <span class="kw">in</span> ls:</span>
<span id="cb3-24"><a href="#cb3-24" tabindex="-1"></a>            ct <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-25"><a href="#cb3-25" tabindex="-1"></a></span>
<span id="cb3-26"><a href="#cb3-26" tabindex="-1"></a>repeats <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb3-27"><a href="#cb3-27" tabindex="-1"></a>gen_time <span class="op">=</span> timeit(generateInputs, number<span class="op">=</span>repeats)</span>
<span id="cb3-28"><a href="#cb3-28" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"manualSearch: </span><span class="sc">{</span>timeit(manualSearch, number<span class="op">=</span>repeats)<span class="op">-</span>gen_time<span class="sc">:.2f}</span><span class="ss">ms"</span>)</span>
<span id="cb3-29"><a href="#cb3-29" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"operatorSearch: </span><span class="sc">{</span>timeit(operatorSearch, number<span class="op">=</span>repeats)<span class="op">-</span>gen_time<span class="sc">:.2f}</span><span class="ss">ms"</span>)</span></code></pre>
</div>
<p>This results in the manual Python implementation being 5x slower,
doing the exact same operation!</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>manualSearch: 152.15ms
operatorSearch: 28.43ms</code></pre>
</div>
<p>An easy approach to follow is that if two blocks of code do the same
operation, the one that contains less Python is probably faster. This
won’t apply if you’re using 3rd party packages written purely in Python
though.</p>
</section><section><h2 class="section-heading" id="example-parsing-data-from-a-text-file">Example: Parsing data from a text file<a class="anchor" aria-label="anchor" href="#example-parsing-data-from-a-text-file"></a>
</h2>
<hr class="half-width">
<p>In C, since there is no high-level <code>string</code> datatype,
parsing strings can be fairly arduous work where you repeatedly look for
the index of a separator character in the string and use that index to
split the string up.</p>
<div id="challenge1" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Challenge</h3>
<div class="callout-content">
<p>Let’s say we have read in some data from a text file, each line
containing a time bin and a mean energy:</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>f <span class="op">=</span> [</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>    <span class="st">' 0000   0.9819 '</span>,</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>    <span class="st">' 0001   0.3435 '</span>,</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>    <span class="co"># ...</span></span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>    <span class="st">' 0099   0.2275 '</span>,</span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a>    <span class="st">' 0100   0.7067 '</span>,</span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a>    <span class="co"># ...</span></span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a>]</span></code></pre>
</div>
<p>If you’ve a C programming background, you may write the following
code to parse the data into a dictionary:</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="kw">def</span> manualSplit():</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>    data <span class="op">=</span> {}</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> f:</span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>        first_char <span class="op">=</span> line.find(<span class="st">"0"</span>)</span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a>        end_time <span class="op">=</span> line.find(<span class="st">" "</span>, first_char, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>        energy_found <span class="op">=</span> line.find(<span class="st">"."</span>, end_time, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>        begin_energy <span class="op">=</span> line.rfind(<span class="st">" "</span>, end_time, energy_found)</span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a>        end_energy <span class="op">=</span> line.find(<span class="st">" "</span>, energy_found)</span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a>        <span class="cf">if</span> end_energy <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a>            end_energy <span class="op">=</span> <span class="bu">len</span>(line)</span>
<span id="cb6-12"><a href="#cb6-12" tabindex="-1"></a>        </span>
<span id="cb6-13"><a href="#cb6-13" tabindex="-1"></a>        time <span class="op">=</span> line[first_char:end_time]</span>
<span id="cb6-14"><a href="#cb6-14" tabindex="-1"></a>        energy <span class="op">=</span> line[begin_energy <span class="op">+</span> <span class="dv">1</span>:end_energy]</span>
<span id="cb6-15"><a href="#cb6-15" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" tabindex="-1"></a>        data[time] <span class="op">=</span> energy</span>
<span id="cb6-17"><a href="#cb6-17" tabindex="-1"></a>    <span class="cf">return</span> data</span></code></pre>
</div>
<p>Can you find a shorter, more easily understandable way to write this
in Python?</p>
</div>
</div>
</div>
<div id="accordionHint1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button hint-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseHint1" aria-expanded="false" aria-controls="collapseHint1">
  <h4 class="accordion-header" id="headingHint1"> Give me a hint </h4>
</button>
<div id="collapseHint1" class="accordion-collapse collapse" aria-labelledby="headingHint1" data-bs-parent="#accordionHint1">
<div class="accordion-body">
<p>Python strings have a lot of methods to perform common operations,
like removing suffixes, replacing substrings, joining or splitting,
stripping whitespaces, and much more. See Python’s <a href="https://docs.python.org/3/library/stdtypes.html#string-methods" class="external-link">string
methods documentation</a> for a full list.</p>
</div>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="kw">def</span> builtinSplit():</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>    data <span class="op">=</span> {}</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> f:</span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a>        time, energy <span class="op">=</span> line.split()</span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a>        data[time] <span class="op">=</span> energy</span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a>    <span class="cf">return</span> data</span></code></pre>
</div>
<p>This code is not just much more readable; it is also more flexible,
since it does not rely on the precise formatting of the input strings.
(For example, the line <code>first_char = line.find("0")</code> in the
original code assumes that the time bin starts with the digit 0. That
code would likely malfunction if the input file had more than 1000 time
bins.)</p>
<p>The code that’s executed by CPython may use a similar approach as in
<code>manualSplit()</code>; however, since this is all happening “under
the hood” in C code, it is once again faster.</p>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a></span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">10_000</span>  <span class="co"># Number of elements in the list</span></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a><span class="co"># Ensure every list is the same</span></span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a>random.seed(<span class="dv">12</span>)</span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a>f <span class="op">=</span> [<span class="ss">f" </span><span class="sc">{</span>i<span class="sc">:0&gt;6d}</span><span class="ss"> </span><span class="sc">{</span>random<span class="sc">.</span>random()<span class="sc">:8.4f}</span><span class="ss"> "</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N)]</span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a>repeats <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"manualSplit: </span><span class="sc">{</span>timeit(manualSplit, <span class="bu">globals</span><span class="op">=</span><span class="bu">globals</span>(), number<span class="op">=</span>repeats)<span class="sc">:.3f}</span><span class="ss">ms"</span>)</span>
<span id="cb8-10"><a href="#cb8-10" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"builtinSplit: </span><span class="sc">{</span>timeit(builtinSplit, <span class="bu">globals</span><span class="op">=</span><span class="bu">globals</span>(), number<span class="op">=</span>repeats)<span class="sc">:.3f}</span><span class="ss">ms"</span>)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>manualSplit: 1.797ms
builtinSplit: 0.796ms</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="challenge2" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Challenge</h3>
<div class="callout-content">
<p>If you’ve brought a project you want to work on: Do you have any
similar code in there, which is hard to understand because it contains a
lot of low-level step-by-step instructions?</p>
</div>
</div>
</div>
<div id="accordionHint2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button hint-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseHint2" aria-expanded="false" aria-controls="collapseHint2">
  <h4 class="accordion-header" id="headingHint2"> Give me a hint </h4>
</button>
<div id="collapseHint2" class="accordion-collapse collapse" aria-labelledby="headingHint2" data-bs-parent="#accordionHint2">
<div class="accordion-body">
<!-- Typical cases might include reading data from a file, …, … TODO: more examples? -->
<p>(Before you try to rewrite those parts of your code, use a profiler
to see whether those parts have a noticeable impact on the overall
performance of your project. Remember the Donald Knuth quote!)</p>
</div>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-optimisation-data-structures-algorithms"><p>Content from <a href="optimisation-data-structures-algorithms.html">Data Structures &amp; Algorithms</a></p>
<hr>
<p>Last updated on 2025-05-11 |

        <a href="https://github.com/RSE-Sheffield/pando-python/edit/main/episodes/optimisation-data-structures-algorithms.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What’s the most efficient way to construct a list?</li>
<li>When should tuples be used?</li>
<li>When are sets appropriate?</li>
<li>What is the best way to search a list?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Able to summarise how lists and tuples work behind the scenes.</li>
<li>Able to identify appropriate use-cases for tuples.</li>
<li>Able to utilise dictionaries and sets effectively</li>
<li>Able to use <code>bisect_left()</code> to perform a binary search of
a list or array</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="this-episode-is-challenging" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="this-episode-is-challenging" class="callout-inner">
<h3 class="callout-title">This episode is challenging!</h3>
<div class="callout-content">
<p>Within this episode you will be introduced to how certain
data-structures and algorithms work.</p>
<p>This is used to explain why one approach is likely to execute faster
than another.</p>
<p>It matters that you are able to recognise the faster/slower
approaches, not that you can describe or reimplement these
data-structures and algorithms yourself.</p>
</div>
</div>
</div>
<section><h2 class="section-heading" id="lists">Lists<a class="anchor" aria-label="anchor" href="#lists"></a>
</h2>
<hr class="half-width">
<p>Lists are a fundamental data structure within Python.</p>
<p>It is implemented as a form of dynamic array found within many
programming languages by different names (C++: <code>std::vector</code>,
Java: <code>ArrayList</code>, R: <code>vector</code>, Julia:
<code>Vector</code>).</p>
<p>They allow direct and sequential element access, with the convenience
to append items.</p>
<p>This is achieved by internally storing items in a static array. This
array however can be longer than the list, so the current length of the
list is stored alongside the array. When an item is appended, the list
checks whether it has enough spare space to add the item to the end. If
it doesn’t, it will re-allocate a larger array, copy across the
elements, and deallocate the old array. The item to be appended is then
copied to the end and the counter which tracks the list’s length is
incremented.</p>
<!-- Based on ICR-RSE's visual note: https://icr-rse-group.github.io/carpentry-pando-python/optimisation-data-structures-algorithms.html#lists -->
<figure><img src="fig/list-append.png" alt="A list uses a contiguous block of memory, similar to an array, for storing the pointers to its elements. It is depicted as a series of five adjacent boxes, labelled 'P1' to 'P5', representing pointers to the list's elements. It can have additional storage beyond its length to make appends faster. An illustration shows the previous list with two extra empty boxes marked with question marks, indicating spare elements. Below, Python code `len(my_list) == 5` and `my_list.append(6)` is shown. After appending, the first of the previously empty boxes contains 'P6', and the last one remains empty. The length is now `len(my_list) == 6`. Appending to a full list causes it to grow. This makes some appends slower. An illustration depicts a full list with 'P1' through 'P7' in adjacent boxes and a label &quot;No spare elements!&quot;. Below, Python code `len(my_list) == 7` and `my_list.append(8)` is shown. The result is a new, larger continuous block of memory with 'P1' through 'P8' followed by a question mark in an additional box, indicating one spare element. The label &quot;2 new elements&quot; with curved arrows suggests that when the list grows, it typically allocates more memory than just the space for the new element. A concluding note states that a list will typically grow by 12.5%, hence shorter lists will grow more frequently when appending." class="figure mx-auto d-block"><div class="figcaption">A visual diagram of list storage.</div>
</figure><p>The amount the internal array grows by is dependent on the particular
list implementation’s growth factor. CPython for example uses <a href="https://github.com/python/cpython/blob/a571a2fd3fdaeafdfd71f3d80ed5a3b22b63d0f7/Objects/listobject.c#L74" class="external-link"><code>newsize + (newsize &gt;&gt; 3) + 6</code></a>,
which works out to an over allocation of roughly ~12.5%.</p>
<figure><img src="fig/cpython_list_allocations.png" alt="A line graph displaying the relationship between the number of calls to append() and the number of internal resizes of a CPython list. It has a logarithmic relationship, at 1 million appends there have been 84 internal resizes." class="figure mx-auto d-block"><div class="figcaption">The relationship between the number of appends
to an empty list, and the number of internal resizes in CPython.</div>
</figure><p>This has two implications:</p>
<ul>
<li>If you are growing a list with <code>append()</code>, there will be
large amounts of redundant allocations and copies as the list
grows.</li>
<li>The resized list may use up to 12.5% excess memory.
<!-- This only applies when resizing a list. When creating a list of a particular size from scratch, CPython will not overallocate as much memory: https://github.com/python/cpython/blob/a571a2fd3fdaeafdfd71f3d80ed5a3b22b63d0f7/Objects/listobject.c#L101 -->
</li>
</ul>
<div class="section level3">
<h3 id="list-comprehension">List Comprehension<a class="anchor" aria-label="anchor" href="#list-comprehension"></a>
</h3>
<p>If creating a list via <code>append()</code> is undesirable, the
natural alternative is to use list-comprehension.</p>
<p>List comprehension can be twice as fast at building lists than using
<code>append()</code>. This is primarily because list-comprehension
allows Python to offload much of the computation into faster C code.
General Python loops in contrast can be used for much more, so they
remain in Python bytecode during computation which has additional
overheads.</p>
<p>This can be demonstrated with the below benchmark:</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">from</span> timeit <span class="im">import</span> timeit</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="kw">def</span> list_append():</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>    li <span class="op">=</span> []</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">100000</span>):</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a>        li.append(i)</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a><span class="kw">def</span> list_preallocate():</span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a>    li <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span><span class="dv">100000</span></span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">100000</span>):</span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a>        li[i] <span class="op">=</span> i</span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a><span class="kw">def</span> list_comprehension():</span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a>    li <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">100000</span>)]</span>
<span id="cb1-15"><a href="#cb1-15" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" tabindex="-1"></a>repeats <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb1-17"><a href="#cb1-17" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Append: </span><span class="sc">{</span>timeit(list_append, number<span class="op">=</span>repeats)<span class="sc">:.2f}</span><span class="ss">ms"</span>)</span>
<span id="cb1-18"><a href="#cb1-18" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Preallocate: </span><span class="sc">{</span>timeit(list_preallocate, number<span class="op">=</span>repeats)<span class="sc">:.2f}</span><span class="ss">ms"</span>)</span>
<span id="cb1-19"><a href="#cb1-19" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Comprehension: </span><span class="sc">{</span>timeit(list_comprehension, number<span class="op">=</span>repeats)<span class="sc">:.2f}</span><span class="ss">ms"</span>)</span></code></pre>
</div>
<p><code>timeit</code> is used to run each function 1000 times,
providing the below averages:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Append: 3.50ms
Preallocate: 2.48ms
Comprehension: 1.69ms</code></pre>
</div>
<p>Results will vary between Python versions, hardware and list lengths.
But in this example list comprehension was 2x faster, with pre-allocate
fairing in the middle. Although this is milliseconds, this can soon add
up if you are regularly creating lists.</p>
</div>
</section><section><h2 class="section-heading" id="tuples">Tuples<a class="anchor" aria-label="anchor" href="#tuples"></a>
</h2>
<hr class="half-width">
<p>In contrast to lists, Python’s tuples are immutable static arrays
(similar to strings): Their elements cannot be modified and they cannot
be resized.</p>
<p>Their potential use-cases are greatly reduced due to these two
limitations, they are only suitable for groups of immutable
properties.</p>
<p>Tuples can still be joined with the <code>+</code> operator, similar
to appending lists, however the result is always a newly allocated tuple
(without a list’s over-allocation).</p>
<p>Python caches a large number of short (1-20 element) tuples. This
greatly reduces the cost of creating and destroying them during
execution at the cost of a slight memory overhead.</p>
<p>This can be easily demonstrated with Python’s <code>timeit</code>
module in your console.</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">SH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode sh" tabindex="0"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="op">&gt;</span>python <span class="ex">-m</span> timeit <span class="st">"li = [0,1,2,3,4,5]"</span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a><span class="ex">10000000</span> loops, best of 5: 26.4 nsec per loop</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a><span class="op">&gt;</span>python <span class="ex">-m</span> timeit <span class="st">"tu = (0,1,2,3,4,5)"</span></span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a><span class="ex">50000000</span> loops, best of 5: 7.99 nsec per loop</span></code></pre>
</div>
<p>It takes 3x as long to allocate a short list than a tuple of equal
length. This gap only grows with the length, as the tuple cost remains
roughly static whereas the cost of allocating the list grows
slightly.</p>
</section><section><h2 class="section-heading" id="dictionaries">Dictionaries<a class="anchor" aria-label="anchor" href="#dictionaries"></a>
</h2>
<hr class="half-width">
<p>Dictionaries are another fundamental Python data-structure. They
provide a key-value store, whereby unique keys with no intrinsic order
map to attached values.</p>
<div id="no-intrinsic-order" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="no-intrinsic-order" class="callout-inner">
<h3 class="callout-title">“no intrinsic order”</h3>
<div class="callout-content">
<p>Since Python 3.6, the items within a dictionary will iterate in the
order that they were inserted. This does not apply to sets.</p>
<p><code>OrderedDict</code> still exists, and may be preferable if the
order of items is important when performing whole-dictionary
equality.</p>
</div>
</div>
</div>
<div class="section level3">
<h3 id="hashing-data-structures">Hashing Data Structures<a class="anchor" aria-label="anchor" href="#hashing-data-structures"></a>
</h3>
<p>Python’s dictionaries are implemented as hashing data structures, we
can understand these at a high-level with an analogy:</p>
<p>A Python list is like having a single long bookshelf. When you buy a
new book (append a new element to the list), you place it at the far end
of the shelf, right after all the previous books.</p>
<figure><img src="fig/bookshelf_list.jpg" alt="An image of a single long bookshelf, with a large number of books." class="figure mx-auto d-block"><div class="figcaption">A bookshelf corresponding to a Python
list.</div>
</figure><p>A Python dictionary is more like a bookcase with several shelves,
labelled by genre (sci-fi, romance, children’s books, non-fiction, …)
and author surname. When you buy a new book by Jules Verne, you might
place it on the shelf labelled "Sci-Fi, V–Z". And if you keep adding
more books, at some point you’ll move to a larger bookcase with more
shelves (and thus more fine-grained sorting), to make sure you don’t
have too many books on a single shelf.</p>
<figure><img src="fig/bookshelf_dict.jpg" alt='An image of two bookcases, labelled "Sci-Fi" and "Romance". Each bookcase contains shelves labelled in alphabetical order, with zero or few books on each shelf.' class="figure mx-auto d-block"><div class="figcaption">A bookshelf corresponding to a Python
dictionary.</div>
</figure><p>Now, let’s say a friend wanted to borrow the book "‘—All You
Zombies—’" by Robert Heinlein. If I had my books arranged on a single
bookshelf (in a list), I would have to look through every book I own in
order to find it. However, if I had a bookcase with several shelves (a
hashing data structure), I know immediately that I need to check the
shelf "Sci-Fi, G—J", so I’d be able to find it much more quickly!</p>

<p>When a value is inserted into a dictionary, its key is hashed to
decide on which “shelf” it should be stored. Most items will have a
unique shelf, allowing them to be accessed directly. This is typically
much faster for locating a specific item than searching a list.</p>
<div id="keys" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="keys" class="callout-inner">
<h3 class="callout-title">Keys</h3>
<div class="callout-content">
<p>A dictionary’s keys will typically be a core Python type such as a
number or string. However, multiple of these can be combined as a tuple
to form a compound key, or a custom class can be used if the methods
<code>__hash__()</code> and <code>__eq__()</code> have been
implemented.</p>
<p>You can implement <code>__hash__()</code> by utilising the ability
for Python to hash tuples, avoiding the need to implement a bespoke hash
function.</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="kw">class</span> MyKey:</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, _a, _b, _c):</span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a>        <span class="va">self</span>.a <span class="op">=</span> _a</span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a>        <span class="va">self</span>.b <span class="op">=</span> _b</span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a>        <span class="va">self</span>.c <span class="op">=</span> _c</span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__eq__</span>(<span class="va">self</span>, other):</span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a>        <span class="cf">return</span> (<span class="bu">isinstance</span>(other, <span class="bu">type</span>(<span class="va">self</span>))</span>
<span id="cb4-10"><a href="#cb4-10" tabindex="-1"></a>                <span class="kw">and</span> (<span class="va">self</span>.a, <span class="va">self</span>.b, <span class="va">self</span>.c) <span class="op">==</span> (other.a, other.b, other.c))</span>
<span id="cb4-11"><a href="#cb4-11" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__hash__</span>(<span class="va">self</span>):</span>
<span id="cb4-13"><a href="#cb4-13" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">hash</span>((<span class="va">self</span>.a, <span class="va">self</span>.b, <span class="va">self</span>.c))</span>
<span id="cb4-14"><a href="#cb4-14" tabindex="-1"></a></span>
<span id="cb4-15"><a href="#cb4-15" tabindex="-1"></a><span class="bu">dict</span> <span class="op">=</span> {}</span>
<span id="cb4-16"><a href="#cb4-16" tabindex="-1"></a><span class="bu">dict</span>[MyKey(<span class="st">"one"</span>, <span class="dv">2</span>, <span class="fl">3.0</span>)] <span class="op">=</span> <span class="dv">12</span></span></code></pre>
</div>
<p>The only limitation is that where two objects are equal they must
have the same hash, hence all member variables which contribute to
<code>__eq__()</code> should also contribute to <code>__hash__()</code>
and vice versa (it’s fine to have irrelevant or redundant internal
members contribute to neither).</p>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="sets">Sets<a class="anchor" aria-label="anchor" href="#sets"></a>
</h2>
<hr class="half-width">
<p>Sets are dictionaries without the values (both are declared using
<code>{}</code>), a collection of unique keys equivalent to the
mathematical set. <em>Modern CPython now uses a set implementation
distinct from that of it’s dictionary, however they still behave much
the same in terms of performance characteristics.</em></p>
<p>Sets are used for eliminating duplicates and checking for membership,
and will normally outperform lists especially when the list cannot be
maintained sorted.</p>
<div id="exercise-unique-collection" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="exercise-unique-collection" class="callout-inner">
<h3 class="callout-title">Exercise: Unique Collection</h3>
<div class="callout-content">
<p>There are four implementations in the below example code, each builds
a collection of unique elements from 25,000 where 50% can be expected to
be duplicates.</p>
<p>Estimate how the performance of each approach is likely to stack
up.</p>
<p>If you reduce the value of <code>repeats</code> it will run faster,
how does changing the number of items (<code>N</code>) or the ratio of
duplicates <code>int(N/2)</code> affect performance?</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a><span class="im">from</span> timeit <span class="im">import</span> timeit</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a><span class="kw">def</span> generateInputs(N <span class="op">=</span> <span class="dv">25000</span>):</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>    random.seed(<span class="dv">12</span>)  <span class="co"># Ensure every list is the same </span></span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a>    <span class="cf">return</span> [random.randint(<span class="dv">0</span>,<span class="bu">int</span>(N<span class="op">/</span><span class="dv">2</span>)) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N)]</span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a>    </span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a><span class="kw">def</span> uniqueSet():</span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a>    ls_in <span class="op">=</span> generateInputs()</span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a>    set_out <span class="op">=</span> <span class="bu">set</span>(ls_in)</span>
<span id="cb5-11"><a href="#cb5-11" tabindex="-1"></a>    </span>
<span id="cb5-12"><a href="#cb5-12" tabindex="-1"></a><span class="kw">def</span> uniqueSetAdd():</span>
<span id="cb5-13"><a href="#cb5-13" tabindex="-1"></a>    ls_in <span class="op">=</span> generateInputs()</span>
<span id="cb5-14"><a href="#cb5-14" tabindex="-1"></a>    set_out <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb5-15"><a href="#cb5-15" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> ls_in:</span>
<span id="cb5-16"><a href="#cb5-16" tabindex="-1"></a>        set_out.add(i)</span>
<span id="cb5-17"><a href="#cb5-17" tabindex="-1"></a>    </span>
<span id="cb5-18"><a href="#cb5-18" tabindex="-1"></a><span class="kw">def</span> uniqueList():</span>
<span id="cb5-19"><a href="#cb5-19" tabindex="-1"></a>    ls_in <span class="op">=</span> generateInputs()</span>
<span id="cb5-20"><a href="#cb5-20" tabindex="-1"></a>    ls_out <span class="op">=</span> []</span>
<span id="cb5-21"><a href="#cb5-21" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> ls_in:</span>
<span id="cb5-22"><a href="#cb5-22" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> i <span class="kw">in</span> ls_out:</span>
<span id="cb5-23"><a href="#cb5-23" tabindex="-1"></a>            ls_out.append(i)</span>
<span id="cb5-24"><a href="#cb5-24" tabindex="-1"></a></span>
<span id="cb5-25"><a href="#cb5-25" tabindex="-1"></a><span class="kw">def</span> uniqueListSort():</span>
<span id="cb5-26"><a href="#cb5-26" tabindex="-1"></a>    ls_in <span class="op">=</span> generateInputs()</span>
<span id="cb5-27"><a href="#cb5-27" tabindex="-1"></a>    ls_in.sort()</span>
<span id="cb5-28"><a href="#cb5-28" tabindex="-1"></a>    ls_out <span class="op">=</span> [ls_in[<span class="dv">0</span>]]</span>
<span id="cb5-29"><a href="#cb5-29" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> ls_in:</span>
<span id="cb5-30"><a href="#cb5-30" tabindex="-1"></a>        <span class="cf">if</span> ls_out[<span class="op">-</span><span class="dv">1</span>] <span class="op">!=</span> i:</span>
<span id="cb5-31"><a href="#cb5-31" tabindex="-1"></a>            ls_out.append(i)</span>
<span id="cb5-32"><a href="#cb5-32" tabindex="-1"></a>            </span>
<span id="cb5-33"><a href="#cb5-33" tabindex="-1"></a>repeats <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb5-34"><a href="#cb5-34" tabindex="-1"></a>gen_time <span class="op">=</span> timeit(generateInputs, number<span class="op">=</span>repeats)</span>
<span id="cb5-35"><a href="#cb5-35" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"uniqueSet: </span><span class="sc">{</span>timeit(uniqueSet, number<span class="op">=</span>repeats)<span class="op">-</span>gen_time<span class="sc">:.2f}</span><span class="ss">ms"</span>)</span>
<span id="cb5-36"><a href="#cb5-36" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"uniqueSetAdd: </span><span class="sc">{</span>timeit(uniqueSetAdd, number<span class="op">=</span>repeats)<span class="op">-</span>gen_time<span class="sc">:.2f}</span><span class="ss">ms"</span>)</span>
<span id="cb5-37"><a href="#cb5-37" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"uniqueList: </span><span class="sc">{</span>timeit(uniqueList, number<span class="op">=</span>repeats)<span class="op">-</span>gen_time<span class="sc">:.2f}</span><span class="ss">ms"</span>)</span>
<span id="cb5-38"><a href="#cb5-38" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"uniqueListSort: </span><span class="sc">{</span>timeit(uniqueListSort, number<span class="op">=</span>repeats)<span class="op">-</span>gen_time<span class="sc">:.2f}</span><span class="ss">ms"</span>)</span></code></pre>
</div>
</div>
</div>
</div>
<div id="accordionHint1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button hint-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseHint1" aria-expanded="false" aria-controls="collapseHint1">
  <h4 class="accordion-header" id="headingHint1"> Give me a hint </h4>
</button>
<div id="collapseHint1" class="accordion-collapse collapse" data-bs-parent="#accordionHint1" aria-labelledby="headingHint1">
<div class="accordion-body">
<ul>
<li>
<code>uniqueSet()</code> passes the input list to the constructor
<code>set()</code>.</li>
<li>
<code>uniqueSetAdd()</code> creates an empty set, and then iterates
the input list adding each item individually.</li>
<li>
<code>uniqueList()</code> this naive approach, checks whether each
item in the input list exists in the output list before appending.</li>
<li>
<code>uniqueListSort()</code> sorts the input list, allowing only
the last item of the output list to be checked before appending.</li>
</ul>
<p><em>There is not a version using list comprehension, as it is not
possible to refer to the list being constructed during list
comprehension.</em></p>
</div>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<p>Constructing a set by passing in a single list is the clear
winner.</p>
<p>Constructing a set with a loop and <code>add()</code> (equivalent to
a list’s <code>append()</code>) comes in second. This is slower due to
the pythonic loop, whereas adding a full list at once moves this to
CPython’s back-end.</p>
<p>The naive list approach is 2200x times slower than the fastest
approach, because of how many times the list is searched. This gap will
only grow as the number of items increases.</p>
<p>Sorting the input list reduces the cost of searching the output list
significantly, however it is still 8x slower than the fastest approach.
In part because around half of its runtime is now spent sorting the
list.</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>uniqueSet: 0.30ms
uniqueSetAdd: 0.81ms
uniqueList: 660.71ms
uniqueListSort: 2.67ms</code></pre>
</div>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="searching">Searching<a class="anchor" aria-label="anchor" href="#searching"></a>
</h2>
<hr class="half-width">
<p>Independent of the performance to construct a unique set (as covered
in the previous section), it’s worth identifying the performance to
search the data-structure to retrieve an item or check whether it
exists.</p>
<p>The performance of a hashing data structure is subject to the load
factor and number of collisions. An item that hashes with no collision
can be accessed almost directly, whereas one with collisions will probe
until it finds the correct item or an empty slot. In the worst possible
case, whereby all insert items have collided this would mean checking
every single item. In practice, hashing data-structures are designed to
minimise the chances of this happening and most items should be found or
identified as missing on the first attempt (without probing beyond the
original hash).</p>
<p>In contrast, if searching a list or array, the default approach is to
start at the first item and check all subsequent items until the correct
item has been found. If the correct item is not present, this will
require the entire list to be checked. Therefore the worst-case is
similar to that of the hashing data-structure, however it is guaranteed
in cases where the item is missing. Similarly, on-average we would
expect an item to be found halfway through the list, meaning that an
average search will require checking half of the items.</p>
<p>If however the list or array is sorted, a binary search can be used.
A binary search divides the list in half and checks which half the
target item would be found in, this continues recursively until the
search is exhausted whereby the item should be found or dismissed. This
is significantly faster than performing a linear search of the list,
checking a total of <code>log N</code> items every time.</p>
<p>The below code demonstrates these approaches and their
performance.</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="im">from</span> timeit <span class="im">import</span> timeit</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a><span class="im">from</span> bisect <span class="im">import</span> bisect_left</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">25000</span>  <span class="co"># Number of elements in list</span></span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a>M <span class="op">=</span> <span class="dv">2</span>  <span class="co"># N*M == Range over which the elements span</span></span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a><span class="kw">def</span> generateInputs():</span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a>    random.seed(<span class="dv">12</span>)  <span class="co"># Ensure every list is the same</span></span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a>    st <span class="op">=</span> <span class="bu">set</span>([random.randint(<span class="dv">0</span>, <span class="bu">int</span>(N<span class="op">*</span>M)) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N)])</span>
<span id="cb7-11"><a href="#cb7-11" tabindex="-1"></a>    ls <span class="op">=</span> <span class="bu">list</span>(st)</span>
<span id="cb7-12"><a href="#cb7-12" tabindex="-1"></a>    ls.sort()  <span class="co"># Sort required for binary</span></span>
<span id="cb7-13"><a href="#cb7-13" tabindex="-1"></a>    <span class="cf">return</span> st, ls  <span class="co"># Return both set and list</span></span>
<span id="cb7-14"><a href="#cb7-14" tabindex="-1"></a>    </span>
<span id="cb7-15"><a href="#cb7-15" tabindex="-1"></a><span class="kw">def</span> search_set():</span>
<span id="cb7-16"><a href="#cb7-16" tabindex="-1"></a>    st, _ <span class="op">=</span> generateInputs()</span>
<span id="cb7-17"><a href="#cb7-17" tabindex="-1"></a>    j <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb7-18"><a href="#cb7-18" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">int</span>(N<span class="op">*</span>M), M):</span>
<span id="cb7-19"><a href="#cb7-19" tabindex="-1"></a>        <span class="cf">if</span> i <span class="kw">in</span> st:</span>
<span id="cb7-20"><a href="#cb7-20" tabindex="-1"></a>            j <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb7-21"><a href="#cb7-21" tabindex="-1"></a>    </span>
<span id="cb7-22"><a href="#cb7-22" tabindex="-1"></a><span class="kw">def</span> linear_search_list():</span>
<span id="cb7-23"><a href="#cb7-23" tabindex="-1"></a>    _, ls <span class="op">=</span> generateInputs()</span>
<span id="cb7-24"><a href="#cb7-24" tabindex="-1"></a>    j <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb7-25"><a href="#cb7-25" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">int</span>(N<span class="op">*</span>M), M):</span>
<span id="cb7-26"><a href="#cb7-26" tabindex="-1"></a>        <span class="cf">if</span> i <span class="kw">in</span> ls:</span>
<span id="cb7-27"><a href="#cb7-27" tabindex="-1"></a>            j <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb7-28"><a href="#cb7-28" tabindex="-1"></a>    </span>
<span id="cb7-29"><a href="#cb7-29" tabindex="-1"></a><span class="kw">def</span> binary_search_list():</span>
<span id="cb7-30"><a href="#cb7-30" tabindex="-1"></a>    _, ls <span class="op">=</span> generateInputs()</span>
<span id="cb7-31"><a href="#cb7-31" tabindex="-1"></a>    j <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb7-32"><a href="#cb7-32" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">int</span>(N<span class="op">*</span>M), M):</span>
<span id="cb7-33"><a href="#cb7-33" tabindex="-1"></a>        k <span class="op">=</span> bisect_left(ls, i)</span>
<span id="cb7-34"><a href="#cb7-34" tabindex="-1"></a>        <span class="cf">if</span> k <span class="op">!=</span> <span class="bu">len</span>(ls) <span class="kw">and</span> ls[k] <span class="op">==</span> i:</span>
<span id="cb7-35"><a href="#cb7-35" tabindex="-1"></a>            j <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb7-36"><a href="#cb7-36" tabindex="-1"></a></span>
<span id="cb7-37"><a href="#cb7-37" tabindex="-1"></a>            </span>
<span id="cb7-38"><a href="#cb7-38" tabindex="-1"></a>repeats <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb7-39"><a href="#cb7-39" tabindex="-1"></a>gen_time <span class="op">=</span> timeit(generateInputs, number<span class="op">=</span>repeats)</span>
<span id="cb7-40"><a href="#cb7-40" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"search_set: </span><span class="sc">{</span>timeit(search_set, number<span class="op">=</span>repeats)<span class="op">-</span>gen_time<span class="sc">:.2f}</span><span class="ss">ms"</span>)</span>
<span id="cb7-41"><a href="#cb7-41" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"linear_search_list: </span><span class="sc">{</span>timeit(linear_search_list, number<span class="op">=</span>repeats)<span class="op">-</span>gen_time<span class="sc">:.2f}</span><span class="ss">ms"</span>)</span>
<span id="cb7-42"><a href="#cb7-42" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"binary_search_list: </span><span class="sc">{</span>timeit(binary_search_list, number<span class="op">=</span>repeats)<span class="op">-</span>gen_time<span class="sc">:.2f}</span><span class="ss">ms"</span>)</span></code></pre>
</div>
<p>Searching the set is fastest performing 25,000 searches in 0.04ms.
This is followed by the binary search of the (sorted) list which is 145x
slower, although the list has been filtered for duplicates. A list still
containing duplicates would be longer, leading to a more expensive
search. The linear search of the list is more than 56,600x slower than
the fastest, it really shouldn’t be used!</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>search_set: 0.04ms
linear_search_list: 2264.91ms
binary_search_list: 5.79ms</code></pre>
</div>
<p>These results are subject to change based on the number of items and
the proportion of searched items that exist within the list. However,
the pattern is likely to remain the same. Linear searches should be
avoided!</p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>List comprehension should be preferred when constructing lists.</li>
<li>Where appropriate, tuples should be preferred over Python
lists.</li>
<li>Dictionaries and sets are appropriate for storing a collection of
unique data with no intrinsic order for random access.</li>
<li>When used appropriately, dictionaries and sets are significantly
faster than lists.</li>
<li>If searching a list or array is required, it should be sorted and
searched using <code>bisect_left()</code> (binary search).</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-long-break1"><p>Content from <a href="long-break1.html">Break</a></p>
<hr>
<p>Last updated on 2024-03-28 |

        <a href="https://github.com/RSE-Sheffield/pando-python/edit/main/episodes/long-break1.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<p>Take a break. If you can, move around and look at something away from
your screen to give your eyes a rest. <!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 --></p></section><section id="aio-optimisation-numpy"><p>Content from <a href="optimisation-numpy.html">Using Scientific Python Packages (NumPy, Pandas and more)</a></p>
<hr>
<p>Last updated on 2025-03-24 |

        <a href="https://github.com/RSE-Sheffield/pando-python/edit/main/episodes/optimisation-numpy.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>Why is NumPy often faster than raw Python?</li>
<li>How can processing rows of a Pandas data table be made faster?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Able to utilise NumPy’s vectorisation when operating on arrays of
data.</li>
<li>Able to efficiently process rows when working with data tables.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<p>Earlier, we saw that built-in Python functions, like
<code>sum()</code>, are often faster than manually looping over a list.
This is because those high-level functions are able to do most of the
work in the C backend.</p>
<p>Packages like NumPy and Pandas work similarly: They have been written
in compiled languages to expose this performance across a wide range of
scientific workloads.</p>
<section><h2 class="section-heading" id="using-numpy-effectively">Using NumPy (Effectively)<a class="anchor" aria-label="anchor" href="#using-numpy-effectively"></a>
</h2>
<hr class="half-width">
<p><a href="https://numpy.org/" class="external-link">NumPy</a> is a commonly used package for
scientific computing, which provides a wide variety of methods.</p>
<p>It adds restriction via its own <a href="https://numpy.org/doc/stable/user/basics.types.html" class="external-link">basic numeric
types</a> and static arrays to enable even greater performance than that
of core Python. However if these restrictions are ignored, the
performance can become significantly worse.</p>
<figure><img src="fig/numpy-array-vs-list.png" alt="A diagram illustrating the difference between a NumPy array and a Python list. The NumPy array is a raw block of memory containing numerical values. A Python list contains a header with metadata and multiple items, each of which is a reference to another Python object with its own header and value." class="figure mx-auto d-block"><!-- Figure inspired by https://jakevdp.github.io/blog/2014/05/09/why-python-is-slow/#3.-Python's-object-model-can-lead-to-inefficient-memory-access --></figure><div class="section level3">
<h3 id="numpy-arrays-and-python-lists-live-in-two-separate-worlds">NumPy Arrays and Python Lists Live in Two Separate Worlds<a class="anchor" aria-label="anchor" href="#numpy-arrays-and-python-lists-live-in-two-separate-worlds"></a>
</h3>
<p>NumPy’s arrays (not to be confused with the core Python
<code>array</code> package) are static arrays. Unlike core Python’s
lists, they do not dynamically resize. Therefore, if you wish to append
to a NumPy array, you must call <code>resize()</code> first. If you
treat this like <code>append()</code> for a Python list, resizing for
each individual append, you will be performing significantly more copies
and memory allocations than a Python list.</p>
<p>The below example sees lists and arrays constructed from
<code>range(100000)</code>.</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">from</span> timeit <span class="im">import</span> timeit</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="im">import</span> numpy</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">100000</span>  <span class="co"># Number of elements in list/array</span></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="kw">def</span> list_append():</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>    ls <span class="op">=</span> []</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a>        ls.append(i)</span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a><span class="kw">def</span> array_resize():</span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a>    ar <span class="op">=</span> numpy.zeros(<span class="dv">1</span>)</span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, N):</span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a>        ar.resize(i<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb1-15"><a href="#cb1-15" tabindex="-1"></a>        ar[i] <span class="op">=</span> i</span>
<span id="cb1-16"><a href="#cb1-16" tabindex="-1"></a>        </span>
<span id="cb1-17"><a href="#cb1-17" tabindex="-1"></a>repeats <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb1-18"><a href="#cb1-18" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"list_append: </span><span class="sc">{</span>timeit(list_append, number<span class="op">=</span>repeats)<span class="sc">:.2f}</span><span class="ss">ms"</span>)</span>
<span id="cb1-19"><a href="#cb1-19" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"array_resize: </span><span class="sc">{</span>timeit(array_resize, number<span class="op">=</span>repeats)<span class="sc">:.2f}</span><span class="ss">ms"</span>)</span></code></pre>
</div>
<p>For Python lists, we’ve seen earlier that list comprehensions are
more efficient, so we prefer to avoid using a large number of
<code>append</code> operations if possible. Similarly, we should try to
avoid resizing NumPy arrays, where the overhead is even higher (5.2x
slower than a list, probably 10x slower than list comprehension).</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>list_append: 3.50ms
array_resize: 18.04ms</code></pre>
</div>
<p>Another difference, is that NumPy arrays typically require all data
to be the same type (and a NumPy type). This enables more efficient
access to elements, as they all exist contiguously in memory. In
contrast, elements within Python lists can be of any type so the list
always stores a pointer to where the element actually exists in memory,
rather than the actual element. This has the side effect that if you are
converting back and forth between Python lists and NumPy arrays, there
is an additional overhead as it’s not as simple as copying a single
block of memory.</p>
<div id="callout1" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Callout</h3>
<div class="callout-content">
<p>If you construct a NumPy array from a list containing a complex
object, it will store your data as Python types and you won’t be able to
take advantage of NumPy’s optimisations.</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">SH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode sh" tabindex="0"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="op">&gt;</span>python</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> import <span class="ex">numpy</span> as np</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> a <span class="ex">=</span> np.array<span class="er">(</span><span class="ex">[0.5,</span> 5]<span class="kw">)</span></span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> type<span class="kw">(</span><span class="va">a</span><span class="op">[</span><span class="dv">0</span><span class="op">]</span><span class="kw">)</span></span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a><span class="op">&lt;</span>class <span class="st">'numpy.float64'</span><span class="op">&gt;</span></span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> type<span class="kw">(</span><span class="va">a</span><span class="op">[</span><span class="dv">1</span><span class="op">]</span><span class="kw">)</span></span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a><span class="op">&lt;</span>class <span class="st">'numpy.float64'</span><span class="op">&gt;</span></span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> b <span class="ex">=</span> np.array<span class="er">(</span><span class="ex">[0.5,</span> 5,{<span class="st">"foo"</span>:5}]<span class="kw">)</span></span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> type<span class="kw">(</span><span class="va">b</span><span class="op">[</span><span class="dv">0</span><span class="op">]</span><span class="kw">)</span></span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a><span class="op">&lt;</span>class <span class="st">'float'</span><span class="op">&gt;</span></span>
<span id="cb3-11"><a href="#cb3-11" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> type<span class="kw">(</span><span class="va">b</span><span class="op">[</span><span class="dv">1</span><span class="op">]</span><span class="kw">)</span></span>
<span id="cb3-12"><a href="#cb3-12" tabindex="-1"></a><span class="op">&lt;</span>class <span class="st">'int'</span><span class="op">&gt;</span></span>
<span id="cb3-13"><a href="#cb3-13" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> type<span class="kw">(</span><span class="va">b</span><span class="op">[</span><span class="dv">2</span><span class="op">]</span><span class="kw">)</span></span>
<span id="cb3-14"><a href="#cb3-14" tabindex="-1"></a><span class="op">&lt;</span>class <span class="st">'dict'</span><span class="op">&gt;</span></span></code></pre>
</div>
</div>
</div>
</div>
<p>The below example demonstrates the overhead of mixing Python lists
and NumPy functions.</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">SH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode sh" tabindex="0"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="co"># Python list, numpy.random.choice()</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a><span class="op">&gt;</span>python <span class="ex">-m</span> timeit <span class="at">-s</span> <span class="st">"import numpy; ls = list(range(10000))"</span> <span class="st">"numpy.random.choice(ls)"</span></span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a><span class="ex">1000</span> loops, best of 5: 267 usec per loop</span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a><span class="co"># NumPy array, numpy.random.choice()</span></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a><span class="op">&gt;</span>python <span class="ex">-m</span> timeit <span class="at">-s</span> <span class="st">"import numpy; ar = numpy.arange(10000)"</span> <span class="st">"numpy.random.choice(ar)"</span></span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a><span class="ex">50000</span> loops, best of 5: 4.06 usec per loop</span></code></pre>
</div>
<p>Passing a Python list to <code>numpy.random.choice()</code> is 65.6x
slower than passing a NumPy array. This is the additional overhead of
converting the list to an array. If this function were called multiple
times, it would make sense to transform the list to an array before
calling the function so that overhead is only paid once.</p>
<div id="callout2" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Callout</h3>
<div class="callout-content">
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">SH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode sh" tabindex="0"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="co"># Python list, Manually select 1 item</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a><span class="op">&gt;</span>python <span class="ex">-m</span> timeit <span class="at">-s</span> <span class="st">"import numpy; ls = list(range(10000))"</span> <span class="st">"ls[numpy.random.randint(len(ls))]"</span></span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a><span class="ex">200000</span> loops, best of 5: 1.19 usec per loop</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a><span class="co"># NumPy array, Manually select 1 item</span></span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a><span class="op">&gt;</span>python <span class="ex">-m</span> timeit <span class="at">-s</span> <span class="st">"import numpy; ar = numpy.arange(10000)"</span> <span class="st">"ar[numpy.random.randint(len(ar))]"</span></span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a><span class="ex">200000</span> loops, best of 5: 1.22 usec per loop</span></code></pre>
</div>
<p>Regardless, for this simple application of
<code>numpy.random.choice()</code>, merely using
<code>numpy.random.randint(len())</code> is around 4x faster regardless
whether a Python list or NumPy array is used.</p>
<p>With <code>numpy.random.choice()</code> being such a general function
(it has many possible parameters), there is significant internal
branching. If you don’t require this advanced functionality and are
calling a function regularly, it can be worthwhile considering using a
more limited function.</p>
<p>There is however a trade-off, using
<code>numpy.random.choice()</code> can be clearer to someone reading
your code, and is more difficult to use incorrectly.</p>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="array-broadcasting">Array Broadcasting<a class="anchor" aria-label="anchor" href="#array-broadcasting"></a>
</h3>
<p>NumPy arrays support “<a href="https://numpy.org/doc/stable/user/basics.broadcasting.html" class="external-link">broadcasting</a>”
many mathematical operations or functions. This is a shorthand notation,
where the operation/function is applied element-wise without having to
loop over the array explicitly:</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> ar <span class="op">=</span> np.arange(<span class="dv">6</span>)</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> ar</span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>array([<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>])</span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> ar <span class="op">+</span> <span class="dv">10</span></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a>array([<span class="dv">10</span>, <span class="dv">11</span>, <span class="dv">12</span>, <span class="dv">13</span>, <span class="dv">14</span>, <span class="dv">15</span>])</span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> ar <span class="op">*</span> <span class="dv">2</span></span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>array([ <span class="dv">0</span>,  <span class="dv">2</span>,  <span class="dv">4</span>,  <span class="dv">6</span>,  <span class="dv">8</span>, <span class="dv">10</span>])</span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> ar<span class="op">**</span><span class="dv">2</span></span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a>array([ <span class="dv">0</span>,  <span class="dv">1</span>,  <span class="dv">4</span>,  <span class="dv">9</span>, <span class="dv">16</span>, <span class="dv">25</span>])</span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> np.exp(ar)</span>
<span id="cb6-12"><a href="#cb6-12" tabindex="-1"></a>array([  <span class="fl">1.</span>        ,   <span class="fl">2.71828183</span>,   <span class="fl">7.3890561</span> ,  <span class="fl">20.08553692</span>,</span>
<span id="cb6-13"><a href="#cb6-13" tabindex="-1"></a>        <span class="fl">54.59815003</span>, <span class="fl">148.4131591</span> ])</span></code></pre>
</div>
<div id="callout3" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Callout</h3>
<div class="callout-content">
<p>If you try the same with Python lists, it will usually fail with an
error or give an unexpected result:</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> ls <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="dv">6</span>))</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> ls <span class="op">+</span> <span class="dv">10</span></span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>Traceback (most recent call last):</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>  File <span class="st">"&lt;python-input-8&gt;"</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a>    ls <span class="op">+</span> <span class="dv">10</span></span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a>    <span class="op">~~~^~~~</span></span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a><span class="pp">TypeError</span>: can only concatenate <span class="bu">list</span> (<span class="kw">not</span> <span class="st">"int"</span>) to <span class="bu">list</span></span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> ls <span class="op">*</span> <span class="dv">2</span></span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a>[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]</span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> ls <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb7-11"><a href="#cb7-11" tabindex="-1"></a>Traceback (most recent call last):</span>
<span id="cb7-12"><a href="#cb7-12" tabindex="-1"></a>  File <span class="st">"&lt;python-input-10&gt;"</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></span>
<span id="cb7-13"><a href="#cb7-13" tabindex="-1"></a>    ls <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb7-14"><a href="#cb7-14" tabindex="-1"></a>    <span class="op">~~~^^~~</span></span>
<span id="cb7-15"><a href="#cb7-15" tabindex="-1"></a><span class="pp">TypeError</span>: unsupported operand <span class="bu">type</span>(s) <span class="cf">for</span> <span class="op">**</span> <span class="kw">or</span> <span class="bu">pow</span>(): <span class="st">'list'</span> <span class="kw">and</span> <span class="st">'int'</span></span>
<span id="cb7-16"><a href="#cb7-16" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> np.exp(ls)  <span class="co"># works but is slower, because NumPy converts the list into an array first</span></span>
<span id="cb7-17"><a href="#cb7-17" tabindex="-1"></a>array([  <span class="fl">1.</span>        ,   <span class="fl">2.71828183</span>,   <span class="fl">7.3890561</span> ,  <span class="fl">20.08553692</span>,</span>
<span id="cb7-18"><a href="#cb7-18" tabindex="-1"></a>        <span class="fl">54.59815003</span>, <span class="fl">148.4131591</span> ])</span></code></pre>
</div>
</div>
</div>
</div>
<p>However, broadcasting is not just a nicer way to write mathematical
expressions—it can also give a significant performance boost: Most
modern processors are able to apply one instruction across multiple
variables simultaneously, instead of sequentially. (In computer science,
this is also referred to as “vectorisation”.) The manner by which NumPy
stores data in arrays enables it to vectorise mathematical operations
that are broadcast across arrays.</p>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">SH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode sh" tabindex="0"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="op">&gt;</span> python <span class="ex">-m</span> timeit <span class="at">-s</span> <span class="st">"import numpy; ar = numpy.arange(1)"</span> <span class="st">"ar + 10"</span></span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a><span class="ex">1000000</span> loops, best of 5: 359 nsec per loop</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a><span class="op">&gt;</span> python <span class="ex">-m</span> timeit <span class="at">-s</span> <span class="st">"import numpy; ar = numpy.arange(10)"</span> <span class="st">"ar + 10"</span></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a><span class="ex">1000000</span> loops, best of 5: 362 nsec per loop</span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a><span class="op">&gt;</span> python <span class="ex">-m</span> timeit <span class="at">-s</span> <span class="st">"import numpy; ar = numpy.arange(100)"</span> <span class="st">"ar + 10"</span></span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a><span class="ex">1000000</span> loops, best of 5: 364 nsec per loop</span></code></pre>
</div>
<p>If we were to use a regular <code>for</code> loop, the time to
perform this operation would increase with the length of the array.
However, using NumPy broadcasting we can apply the addition to 1, 10 or
100 elements, all in the same amount of time!</p>

<p>Earlier it was demonstrated that using core Python methods over a
list will outperform a loop, performing the same calculation faster. The
below example takes this a step further by demonstrating the calculation
of a dot product.</p>
<!-- Inspired by High Performance Python Chapter 6 example
Added Python sum array, skipped a couple of others-->
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="im">from</span> timeit <span class="im">import</span> timeit</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">1000000</span>  <span class="co"># Number of elements in list</span></span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a>gen_list <span class="op">=</span> <span class="ss">f"ls = list(range(</span><span class="sc">{</span>N<span class="sc">}</span><span class="ss">))"</span></span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a>gen_array <span class="op">=</span> <span class="ss">f"import numpy; ar = numpy.arange(</span><span class="sc">{</span>N<span class="sc">}</span><span class="ss">, dtype=numpy.int64)"</span></span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a>py_sum_ls <span class="op">=</span> <span class="st">"sum([i*i for i in ls])"</span></span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a>py_sum_ar <span class="op">=</span> <span class="st">"sum(ar*ar)"</span></span>
<span id="cb9-10"><a href="#cb9-10" tabindex="-1"></a>np_sum_ar <span class="op">=</span> <span class="st">"numpy.sum(ar*ar)"</span></span>
<span id="cb9-11"><a href="#cb9-11" tabindex="-1"></a>np_dot_ar <span class="op">=</span> <span class="st">"numpy.dot(ar, ar)"</span></span>
<span id="cb9-12"><a href="#cb9-12" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" tabindex="-1"></a>repeats <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb9-14"><a href="#cb9-14" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"python_sum_list: </span><span class="sc">{</span>timeit(py_sum_ls, setup<span class="op">=</span>gen_list, number<span class="op">=</span>repeats)<span class="sc">:.2f}</span><span class="ss">ms"</span>)</span>
<span id="cb9-15"><a href="#cb9-15" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"python_sum_array: </span><span class="sc">{</span>timeit(py_sum_ar, setup<span class="op">=</span>gen_array, number<span class="op">=</span>repeats)<span class="sc">:.2f}</span><span class="ss">ms"</span>)</span>
<span id="cb9-16"><a href="#cb9-16" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"numpy_sum_array: </span><span class="sc">{</span>timeit(np_sum_ar, setup<span class="op">=</span>gen_array, number<span class="op">=</span>repeats)<span class="sc">:.2f}</span><span class="ss">ms"</span>)</span>
<span id="cb9-17"><a href="#cb9-17" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"numpy_dot_array: </span><span class="sc">{</span>timeit(np_dot_ar, setup<span class="op">=</span>gen_array, number<span class="op">=</span>repeats)<span class="sc">:.2f}</span><span class="ss">ms"</span>)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>python_sum_list: 46.93ms
python_sum_array: 33.26ms
numpy_sum_array: 1.44ms
numpy_dot_array: 0.29ms</code></pre>
</div>
<ul>
<li>
<code>python_sum_list</code> uses list comprehension to perform the
multiplication, followed by the Python core <code>sum()</code>. This
comes out at 46.93ms</li>
<li>
<code>python_sum_array</code> instead directly multiplies the two
arrays (taking advantage of NumPy’s vectorisation) but uses the core
Python <code>sum()</code>, this comes in slightly faster at
33.26ms.</li>
<li>
<code>numpy_sum_array</code> again takes advantage of NumPy’s
vectorisation for the multiplication, and additionally uses NumPy’s
<code>sum()</code> implementation. These two rounds of vectorisation
provide a much faster 1.44ms completion.</li>
<li>
<code>numpy_dot_array</code> instead uses NumPy’s <code>dot()</code>
to calculate the dot product in a single operation. This comes out the
fastest at 0.29ms, 162x faster than <code>python_sum_list</code>.</li>
</ul>
<div id="parallel-numpy" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="parallel-numpy" class="callout-inner">
<h3 class="callout-title">Parallel NumPy</h3>
<div class="callout-content">
<!-- https://superfastpython.com/multithreaded-numpy-functions/ -->
<p>NumPy can sometimes take advantage of auto parallelisation,
particularly on HPC systems.</p>
<p>A small number of functions are backed by BLAS and LAPACK, enabling
even greater speedup.</p>
<p>The <a href="https://numpy.org/doc/stable/reference/routines.linalg.html" class="external-link">supported
functions</a> mostly correspond to linear algebra operations like
<code>numpy.dot()</code>.</p>
<p>The auto-parallelisation of these functions is hardware-dependent, so
you won’t always automatically get the additional benefit of
parallelisation. However, HPC systems should be primed to take
advantage, so try increasing the number of cores you request when
submitting your jobs and see if it improves the performance.</p>
<p><em>This might be why <code>numpy_dot_array</code> is that much
faster than <code>numpy_sum_array</code> in the previous
example!</em></p>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="other-libraries-that-use-numpy">Other Libraries That Use NumPy<a class="anchor" aria-label="anchor" href="#other-libraries-that-use-numpy"></a>
</h2>
<hr class="half-width">
<p>Across the scientific Python software ecosystem, <a href="https://numpy.org/#:~:text=ECOSYSTEM" class="external-link">many domain-specific
packages</a> are built on top of NumPy arrays. Similar to the demos
above, we can often gain significant performance boosts by using these
libraries well.</p>
<div id="challenge-which-libraries-are-you-using-already" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-which-libraries-are-you-using-already" class="callout-inner">
<h3 class="callout-title">Challenge: Which Libraries Are You Using Already?</h3>
<div class="callout-content">
<p>Take a look at the <a href="https://numpy.org/#:~:text=ECOSYSTEM" class="external-link">list of libraries on the
NumPy website</a>. Are you using any of them already?</p>
<p>If you’ve brought a project you want to work on: Are there areas of
the project where you might benefit from adapting one of these libraries
instead of writing your own code from scratch?</p>
</div>
</div>
</div>
<div id="accordionHint1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button hint-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseHint1" aria-expanded="false" aria-controls="collapseHint1">
  <h4 class="accordion-header" id="headingHint1"> Give me a hint </h4>
</button>
<div id="collapseHint1" class="accordion-collapse collapse" data-bs-parent="#accordionHint1" aria-labelledby="headingHint1">
<div class="accordion-body">
<p>These libraries could be specific to your area of research; but they
could also include packages from other fields that provide tools you
need (e.g. statistics or machine learning)!</p>
</div>
</div>
</div>
</div>
<p>Which libraries you may use will depend on your research domain;
here, we’ll show an example from bioinformatics.</p>
<div class="section level3">
<h3 id="example-image-analysis-with-shapely">Example: Image Analysis with Shapely<a class="anchor" aria-label="anchor" href="#example-image-analysis-with-shapely"></a>
</h3>
<p>A bioinformatics researcher had a large data set of images of cells.
She had already reconstructed the locations of cell walls and various
points of interest and needed to identify which points were located in
each cell. To do this, she used the <a href="https://github.com/shapely/shapely" class="external-link">Shapely</a> geometry
library.</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>points_per_polygon <span class="op">=</span> {}</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a><span class="cf">for</span> polygon_idx <span class="kw">in</span> <span class="bu">range</span>(n_polygons):</span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>    current_polygon <span class="op">=</span> polygons.iloc[polygon_idx,:][<span class="st">"geometry"</span>]</span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a>    <span class="co"># manually loop over all points, check if polygon contains that point</span></span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a>    out_points <span class="op">=</span> []</span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_points):</span>
<span id="cb11-8"><a href="#cb11-8" tabindex="-1"></a>        current_point <span class="op">=</span> points.iloc[i, :]</span>
<span id="cb11-9"><a href="#cb11-9" tabindex="-1"></a>        <span class="cf">if</span> current_polygon.contains(current_point[<span class="st">"geometry"</span>]):</span>
<span id="cb11-10"><a href="#cb11-10" tabindex="-1"></a>            out_points.append(current_point.name)</span>
<span id="cb11-11"><a href="#cb11-11" tabindex="-1"></a></span>
<span id="cb11-12"><a href="#cb11-12" tabindex="-1"></a>    points_per_polygon[polygon_idx] <span class="op">=</span> out_points</span></code></pre>
</div>
<p>For about 500k points and 1000 polygons, the initial version of the
code took about 20 hours to run.</p>
<p>Luckily, Shapely is built on top of NumPy, so she was able to apply
functions to an array of points instead and wrote an improved version,
which took just 20 minutes:</p>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="co"># 1) Extract points and corresponding names as two separate NumPy arrays from a larger data frame</span></span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a><span class="co"># This will make it easier to apply vectorised functions below</span></span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>points_array <span class="op">=</span> np.array(points.loc[:,<span class="st">"geometry"</span>])</span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>point_names_array <span class="op">=</span> np.array(points.loc[:,<span class="st">"name"</span>])</span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a>points_per_polygon <span class="op">=</span> {}</span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a><span class="cf">for</span> polygon_idx <span class="kw">in</span> <span class="bu">range</span>(n_polygons):</span>
<span id="cb12-8"><a href="#cb12-8" tabindex="-1"></a>    current_polygon <span class="op">=</span> polygons.iloc[polygon_idx,:][<span class="st">"geometry"</span>]</span>
<span id="cb12-9"><a href="#cb12-9" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" tabindex="-1"></a>    <span class="co"># 2) apply `contains` to an array of points, rather than an individual point</span></span>
<span id="cb12-11"><a href="#cb12-11" tabindex="-1"></a>    points_in_polygon_idx <span class="op">=</span> current_polygon.contains(points_array)</span>
<span id="cb12-12"><a href="#cb12-12" tabindex="-1"></a>    <span class="co"># 3) Filter `point_names_array` to get just the names of points contained in the polygon</span></span>
<span id="cb12-13"><a href="#cb12-13" tabindex="-1"></a>    points_in_polygon <span class="op">=</span> point_names_array[points_in_polygon_idx]</span>
<span id="cb12-14"><a href="#cb12-14" tabindex="-1"></a>    <span class="co"># 4) Turn this array into a Python list and store it in output data</span></span>
<span id="cb12-15"><a href="#cb12-15" tabindex="-1"></a>    points_per_polygon[polygon_idx] <span class="op">=</span> points_in_polygon.tolist()</span></code></pre>
</div>
<p>To vectorise this efficiently, the logic of the code had to be
changed slightly:</p>
<ol style="list-style-type: decimal">
<li>The improved code starts by extracting the
<code>shapely.Point</code>s and corresponding point names as two
separate NumPy arrays from a larger data frame.</li>
<li>It then passes that array of points to
<code>current_polygon.contains()</code>, which uses vectorisation to
speed up the calculation. It returns a NumPy array of booleans
(<code>True</code> or <code>False</code>), describing for each
<code>Point</code> in the input array whether it is contained in
<code>current_polygon</code>.</li>
<li>This boolean array is then <a href="https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing" class="external-link">passed
as an index</a> to the <code>point_names_list</code> array. This returns
a new array with the names of all points that are contained in the
polygon (i.e. where the boolean array had the value
<code>True</code>).</li>
<li>Finally, the contained points are stored as a Python list. (In this
particular case, later parts of the data analysis code expected a list
instead of a NumPy array. Since those parts of the code were “fast
enough”—remember Donald Knuth’s quote in the earlier episode?—the
researcher decided not to spend more time to rewrite them.)</li>
</ol>
<!--
TODO: The following example needs more work to be used by instructors other than me.
And since it’s not a very clean example (mixes np arrays and list comprehensions) and hard to extract a nice before/after snippet, maybe it’s better not to include this example in the general course materials? Or only in a callout or instructor note?
--><!--
### Example: Interpolating astrophysical spectra with AstroPy

This is from an open-source package I'm working on, so we can look at the actual pull request where I made this change: https://github.com/SNEWS2/snewpy/pull/310

&rightarrow; See the first table of benchmark results. Note that using a Python `for` loop to calculate the spectrum in 100 different time bins takes 100 times as long as for a single time bin. In the vectorized version, the computing time increases much more slowly.

(Note that energies were already vectorized—that's another factor of 100 we got "for free"!)

Code diff: https://github.com/SNEWS2/snewpy/pull/310/commits/0320b384ff22233818d07913c55c30f5968ae330
 -->
</div>
</section><section><h2 class="section-heading" id="using-pandas-effectively">Using Pandas (Effectively)<a class="anchor" aria-label="anchor" href="#using-pandas-effectively"></a>
</h2>
<hr class="half-width">
<p><a href="https://pandas.pydata.org/" class="external-link">Pandas</a> is the most common
Python package used for scientific computing when working with tabular
data akin to spreadsheets (DataFrames).</p>
<p>Similar to NumPy, Pandas enables greater performance than pure Python
implementations when used correctly, however incorrect usage can
actively harm performance.</p>
<div class="section level3">
<h3 id="operating-on-rows">Operating on Rows<a class="anchor" aria-label="anchor" href="#operating-on-rows"></a>
</h3>
<p>Pandas’ methods by default operate on columns. Each column or series
can be thought of as a NumPy array, highly suitable for
vectorisation.</p>
<p>Following the theme of this episode, iterating over the rows of a
data frame using a <code>for</code> loop is not advised. The pythonic
iteration will be slower than other approaches.</p>
<p>Pandas allows its own methods to be applied to rows in many cases by
passing <code>axis=1</code>, where available these functions should be
preferred over manual loops. Where you can’t find a suitable method,
<code>apply()</code> can be used, which is similar to
<code>map()</code>, to apply your own function to rows.</p>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="im">from</span> timeit <span class="im">import</span> timeit</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a><span class="im">import</span> pandas</span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a><span class="im">import</span> numpy</span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">100000</span>  <span class="co"># Number of rows in DataFrame</span></span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" tabindex="-1"></a><span class="kw">def</span> genDataFrame():</span>
<span id="cb14-8"><a href="#cb14-8" tabindex="-1"></a>    numpy.random.seed(<span class="dv">12</span>)  <span class="co"># Ensure each dataframe is identical</span></span>
<span id="cb14-9"><a href="#cb14-9" tabindex="-1"></a>    <span class="cf">return</span> pandas.DataFrame(</span>
<span id="cb14-10"><a href="#cb14-10" tabindex="-1"></a>    {</span>
<span id="cb14-11"><a href="#cb14-11" tabindex="-1"></a>        <span class="st">"f_vertical"</span>: numpy.random.random(size<span class="op">=</span>N),</span>
<span id="cb14-12"><a href="#cb14-12" tabindex="-1"></a>        <span class="st">"f_horizontal"</span>: numpy.random.random(size<span class="op">=</span>N),</span>
<span id="cb14-13"><a href="#cb14-13" tabindex="-1"></a>        <span class="co"># todo some spurious columns</span></span>
<span id="cb14-14"><a href="#cb14-14" tabindex="-1"></a>    })</span>
<span id="cb14-15"><a href="#cb14-15" tabindex="-1"></a></span>
<span id="cb14-16"><a href="#cb14-16" tabindex="-1"></a><span class="kw">def</span> pythagoras(row):</span>
<span id="cb14-17"><a href="#cb14-17" tabindex="-1"></a>    <span class="cf">return</span> (row[<span class="st">"f_vertical"</span>]<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> row[<span class="st">"f_horizontal"</span>]<span class="op">**</span><span class="dv">2</span>)<span class="op">**</span><span class="fl">0.5</span></span>
<span id="cb14-18"><a href="#cb14-18" tabindex="-1"></a>    </span>
<span id="cb14-19"><a href="#cb14-19" tabindex="-1"></a><span class="kw">def</span> for_range():</span>
<span id="cb14-20"><a href="#cb14-20" tabindex="-1"></a>    rtn <span class="op">=</span> []</span>
<span id="cb14-21"><a href="#cb14-21" tabindex="-1"></a>    df <span class="op">=</span> genDataFrame()</span>
<span id="cb14-22"><a href="#cb14-22" tabindex="-1"></a>    <span class="cf">for</span> row_idx <span class="kw">in</span> <span class="bu">range</span>(df.shape[<span class="dv">0</span>]):</span>
<span id="cb14-23"><a href="#cb14-23" tabindex="-1"></a>        row <span class="op">=</span> df.iloc[row_idx]</span>
<span id="cb14-24"><a href="#cb14-24" tabindex="-1"></a>        rtn.append(pythagoras(row))</span>
<span id="cb14-25"><a href="#cb14-25" tabindex="-1"></a>    <span class="cf">return</span> pandas.Series(rtn)</span>
<span id="cb14-26"><a href="#cb14-26" tabindex="-1"></a></span>
<span id="cb14-27"><a href="#cb14-27" tabindex="-1"></a><span class="kw">def</span> for_iterrows():</span>
<span id="cb14-28"><a href="#cb14-28" tabindex="-1"></a>    rtn <span class="op">=</span> []</span>
<span id="cb14-29"><a href="#cb14-29" tabindex="-1"></a>    df <span class="op">=</span> genDataFrame()</span>
<span id="cb14-30"><a href="#cb14-30" tabindex="-1"></a>    <span class="cf">for</span> row_idx, row <span class="kw">in</span> df.iterrows():</span>
<span id="cb14-31"><a href="#cb14-31" tabindex="-1"></a>        rtn.append(pythagoras(row))</span>
<span id="cb14-32"><a href="#cb14-32" tabindex="-1"></a>    <span class="cf">return</span> pandas.Series(rtn)</span>
<span id="cb14-33"><a href="#cb14-33" tabindex="-1"></a>    </span>
<span id="cb14-34"><a href="#cb14-34" tabindex="-1"></a><span class="kw">def</span> pandas_apply():</span>
<span id="cb14-35"><a href="#cb14-35" tabindex="-1"></a>    df <span class="op">=</span> genDataFrame()</span>
<span id="cb14-36"><a href="#cb14-36" tabindex="-1"></a>    <span class="cf">return</span> df.<span class="bu">apply</span>(pythagoras, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb14-37"><a href="#cb14-37" tabindex="-1"></a></span>
<span id="cb14-38"><a href="#cb14-38" tabindex="-1"></a>repeats <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb14-39"><a href="#cb14-39" tabindex="-1"></a>gentime <span class="op">=</span> timeit(genDataFrame, number<span class="op">=</span>repeats)</span>
<span id="cb14-40"><a href="#cb14-40" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"for_range: </span><span class="sc">{</span>timeit(for_range, number<span class="op">=</span>repeats)<span class="op">*</span><span class="dv">10</span><span class="op">-</span>gentime<span class="sc">:.2f}</span><span class="ss">ms"</span>)</span>
<span id="cb14-41"><a href="#cb14-41" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"for_iterrows: </span><span class="sc">{</span>timeit(for_iterrows, number<span class="op">=</span>repeats)<span class="op">*</span><span class="dv">10</span><span class="op">-</span>gentime<span class="sc">:.2f}</span><span class="ss">ms"</span>)</span>
<span id="cb14-42"><a href="#cb14-42" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"pandas_apply: </span><span class="sc">{</span>timeit(pandas_apply, number<span class="op">=</span>repeats)<span class="op">*</span><span class="dv">10</span><span class="op">-</span>gentime<span class="sc">:.2f}</span><span class="ss">ms"</span>)</span></code></pre>
</div>
<p><code>apply()</code> is 4x faster than the two <code>for</code>
approaches, as it avoids the Python <code>for</code> loop.</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>for_range: 1582.47ms
for_iterrows: 1677.14ms
pandas_apply: 390.49ms</code></pre>
</div>
<p>However, rows don’t exist in memory as arrays (columns do!), so
<code>apply()</code> does not take advantage of NumPy’s vectorisation.
You may be able to go a step further and avoid explicitly operating on
rows entirely by passing only the required columns to NumPy.</p>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="kw">def</span> vectorize():</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>    df <span class="op">=</span> genDataFrame()</span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>    <span class="cf">return</span> pandas.Series(numpy.sqrt(numpy.square(df[<span class="st">"f_vertical"</span>]) <span class="op">+</span> numpy.square(df[<span class="st">"f_horizontal"</span>])))</span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a>    </span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"vectorize: </span><span class="sc">{</span>timeit(vectorize, number<span class="op">=</span>repeats)<span class="op">-</span>gentime<span class="sc">:.2f}</span><span class="ss">ms"</span>)</span></code></pre>
</div>
<p>264x faster than <code>apply()</code>, 1000x faster than the two
<code>for</code> approaches!</p>
<pre><code>vectorize: 1.48ms</code></pre>
<p>It won’t always be possible to take full advantage of vectorisation,
for example you may have conditional logic.</p>
<p>An alternate approach is converting your DataFrame to a Python
dictionary using <code>to_dict(orient='index')</code>. This creates a
nested dictionary, where each row of the outer dictionary is an internal
dictionary. This can then be processed via list-comprehension:</p>
<div class="codewrapper sourceCode" id="cb18">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a><span class="kw">def</span> to_dict():</span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a>    df <span class="op">=</span> genDataFrame()</span>
<span id="cb18-3"><a href="#cb18-3" tabindex="-1"></a>    df_as_dict <span class="op">=</span> df.to_dict(orient<span class="op">=</span><span class="st">'index'</span>)</span>
<span id="cb18-4"><a href="#cb18-4" tabindex="-1"></a>    <span class="cf">return</span> pandas.Series([(r[<span class="st">'f_vertical'</span>]<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> r[<span class="st">'f_horizontal'</span>]<span class="op">**</span><span class="dv">2</span>)<span class="op">**</span><span class="fl">0.5</span> <span class="cf">for</span> r <span class="kw">in</span> df_as_dict.values()])</span>
<span id="cb18-5"><a href="#cb18-5" tabindex="-1"></a></span>
<span id="cb18-6"><a href="#cb18-6" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"to_dict: </span><span class="sc">{</span>timeit(to_dict, number<span class="op">=</span>repeats)<span class="op">*</span><span class="dv">10</span><span class="op">-</span>gentime<span class="sc">:.2f}</span><span class="ss">ms"</span>)</span></code></pre>
</div>
<p>Whilst still nearly 100x slower than pure vectorisation, it’s twice
as fast as <code>apply()</code>.</p>
<div class="codewrapper sourceCode" id="cb19">
<h3 class="code-label">SH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode sh" tabindex="0"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="ex">to_dict:</span> 131.15ms</span></code></pre>
</div>
<p>This is because indexing into Pandas’ <code>Series</code> (rows) is
significantly slower than a Python dictionary. There is a slight
overhead to creating the dictionary (40ms in this example), however the
stark difference in access speed is more than enough to overcome that
cost for any large DataFrame.</p>
<div class="codewrapper sourceCode" id="cb20">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a><span class="im">from</span> timeit <span class="im">import</span> timeit</span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pandas</span>
<span id="cb20-3"><a href="#cb20-3" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">100000</span>  <span class="co"># Number of rows in DataFrame</span></span>
<span id="cb20-5"><a href="#cb20-5" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" tabindex="-1"></a><span class="kw">def</span> genInput():</span>
<span id="cb20-7"><a href="#cb20-7" tabindex="-1"></a>    s <span class="op">=</span> pandas.Series({<span class="st">'a'</span> : <span class="dv">1</span>, <span class="st">'b'</span> : <span class="dv">2</span>})</span>
<span id="cb20-8"><a href="#cb20-8" tabindex="-1"></a>    d <span class="op">=</span> {<span class="st">'a'</span> : <span class="dv">1</span>, <span class="st">'b'</span> : <span class="dv">2</span>}</span>
<span id="cb20-9"><a href="#cb20-9" tabindex="-1"></a>    <span class="cf">return</span> s, d</span>
<span id="cb20-10"><a href="#cb20-10" tabindex="-1"></a></span>
<span id="cb20-11"><a href="#cb20-11" tabindex="-1"></a><span class="kw">def</span> series():</span>
<span id="cb20-12"><a href="#cb20-12" tabindex="-1"></a>    s, _ <span class="op">=</span> genInput()</span>
<span id="cb20-13"><a href="#cb20-13" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb20-14"><a href="#cb20-14" tabindex="-1"></a>        y <span class="op">=</span> s[<span class="st">'a'</span>] <span class="op">*</span> s[<span class="st">'b'</span>]</span>
<span id="cb20-15"><a href="#cb20-15" tabindex="-1"></a></span>
<span id="cb20-16"><a href="#cb20-16" tabindex="-1"></a><span class="kw">def</span> dictionary():</span>
<span id="cb20-17"><a href="#cb20-17" tabindex="-1"></a>    _, d <span class="op">=</span> genInput()</span>
<span id="cb20-18"><a href="#cb20-18" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb20-19"><a href="#cb20-19" tabindex="-1"></a>        y <span class="op">=</span> d[<span class="st">'a'</span>] <span class="op">*</span> d[<span class="st">'b'</span>]</span>
<span id="cb20-20"><a href="#cb20-20" tabindex="-1"></a></span>
<span id="cb20-21"><a href="#cb20-21" tabindex="-1"></a>repeats <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb20-22"><a href="#cb20-22" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"series: </span><span class="sc">{</span>timeit(series, number<span class="op">=</span>repeats)<span class="sc">:.2f}</span><span class="ss">ms"</span>)</span>
<span id="cb20-23"><a href="#cb20-23" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"dictionary: </span><span class="sc">{</span>timeit(dictionary, number<span class="op">=</span>repeats)<span class="sc">:.2f}</span><span class="ss">ms"</span>)</span></code></pre>
</div>
<p>65x slower!</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>series: 237.25ms
dictionary: 3.63ms</code></pre>
</div>
</div>
<div class="section level3">
<h3 id="filter-early">Filter Early<a class="anchor" aria-label="anchor" href="#filter-early"></a>
</h3>
<p>If you can filter your rows before processing, rather than after, you
may significantly reduce the amount of processing and memory used.</p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>Python is an interpreted language, this adds an additional overhead
at runtime to the execution of Python code. Many core Python and NumPy
functions are implemented in faster C/C++, free from this overhead.</li>
<li>NumPy can take advantage of vectorisation to process arrays, which
can greatly improve performance.</li>
<li>Many domain-specific packages are built on top of NumPy and can
offer similar performance boosts.</li>
<li>Pandas’ data tables store columns as arrays, therefore operations
applied to columns can take advantage of NumPy’s vectorisation.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</section></section><section id="aio-optimisation-use-latest"><p>Content from <a href="optimisation-use-latest.html">Keep Python &amp; Packages up to Date</a></p>
<hr>
<p>Last updated on 2025-03-08 |

        <a href="https://github.com/RSE-Sheffield/pando-python/edit/main/episodes/optimisation-use-latest.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>Why would a newer version of Python or a package be faster?</li>
<li>Are there any risks to updating Python and packages?</li>
<li>How can reproducibility be ensured through package upgrades?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Able to explain why using the latest versions of Python and packages
is beneficial.</li>
<li>Able to identify when updating is not possible due to
incompatibilities.</li>
<li>Able to ensure code remains reproducible through package
changes.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<hr class="half-width">
<!-- Why it's important to use the most recent Python and packages viable --><p>It’s important to use the latest Python wherever feasible. In
addition to new features and fixes, much work has been completed over
the lifetime of Python 3 to improve the performance of the language.</p>
<blockquote>
<p><a href="https://docs.python.org/3/whatsnew/3.11.html" class="external-link">Python
3.11</a> is between 10-60% faster than Python 3.10. On average, we
measured a 1.25x speedup on the standard benchmark suite.</p>
</blockquote>
<p>Future proposals, such as changes to the <a href="https://tonybaloney.github.io/posts/python-gets-a-jit.html" class="external-link">JIT</a>
and <a href="https://peps.python.org/pep-0703/" class="external-link">GIL</a> will provide
further improvements to performance.</p>
<p>Similarly, major packages with a performance focus such as NumPy and
Pandas, should be kept up to date for the same reasons.</p>
<!-- performance regressions for major packages are rare -->
<p>These improvements are often free, requiring minimal changes to any
code (unlike the jump from Python 2 to Python 3).</p>
<p>Performance regressions within major packages should be considered
rare, they often track performance alongside their test suites.</p>
<div id="support-for-older-python-versions-in-the-scientific-python-ecosystem" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="support-for-older-python-versions-in-the-scientific-python-ecosystem" class="callout-inner">
<h3 class="callout-title">Support for older Python versions in the Scientific Python ecosystem</h3>
<div class="callout-content">
<p>In the last few years, many important packages in the Scientific
Python ecosystem have agreed <a href="https://scientific-python.org/specs/spec-0000/" class="external-link">a common
policy</a> to support previous versions of Python for 3 years. For
example, since October 2024, these packages stopped supporting Python
3.10; so if you are still using Python 3.10 (or even older versions),
you’re now losing access to new features and performance improvements in
NumPy, SciPy, Matplotlib and many other libraries. Time to update!</p>
</div>
</div>
</div>
<!-- Not always possible due to incompatibilities -->
<p>However, the more packages and language features your code touches,
and the older the Python it currently uses, the greater chance of
incompatibilities making it difficult to upgrade.</p>
<!-- Updates may include breaking changes, important to have validation inplace to ensure results aren't affected -->
<p>Similar to optimising, when updating it’s important to have tests in
place to validate the correctness of your code before and after changes.
An update to a single small dependent package could introduce a breaking
change. This could cause your code to crash, or worse subtly change your
results.</p>
</section><section><h2 class="section-heading" id="updating-python-packages">Updating Python &amp; Packages<a class="anchor" aria-label="anchor" href="#updating-python-packages"></a>
</h2>
<hr class="half-width">
<!-- Not as relevant if you are starting from scratch --><p><em>This isn’t as relevant if you’re starting from scratch. Simply
make sure you’ve installed the latest Python before you start.</em></p>
<!-- todo recommended way, because Python is incredibly bad at this -->
<p>If you have been working with an existing Python installation, the
upgrade process for Python itself depends on how you installed your
current version. (E.g. via conda, official installer from python.org,
package manager like Homebrew/apt/yum/…)</p>
<p>For packages you’re using, you can update those with the same package
manager you used to installed them:</p>
<ul>
<li>via <code>pip</code>,
e.g. <code>pip install --upgrade numpy</code>
</li>
<li>via <code>conda</code>,
e.g. <code>conda update &lt;PACKAGE&gt;</code>
</li>
</ul>
<!-- Worth also mentioning for same reason, to have requirements.txt? --><div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>Where feasible, the latest version of Python and packages should be
used as they can include significant free improvements to the
performance of your code.</li>
<li>There is a risk that updating Python or packages will not be
possible to due to version incompatibilities or will require breaking
changes to your code.</li>
<li>Changes to packages may impact results output by your code, ensure
you have a method of validation ready prior to attempting upgrades.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-optimisation-latency"><p>Content from <a href="optimisation-latency.html">Understanding Latency</a></p>
<hr>
<p>Last updated on 2025-05-11 |

        <a href="https://github.com/RSE-Sheffield/pando-python/edit/main/episodes/optimisation-latency.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>Why is it faster to read/write a single 100 MB file, than 100 files
of 1 MB each?</li>
<li>How many orders of magnitude slower are disk accesses than RAM?</li>
<li>What’s the cost of creating a list?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Able to identify the relationship between different latencies
relevant to software.</li>
<li>Demonstrate how to implement parallel network requests.</li>
<li>Justify the re-use of existing variables over creating new
ones.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="accessing-disk">Accessing Disk<a class="anchor" aria-label="anchor" href="#accessing-disk"></a>
</h2>
<hr class="half-width">
<!-- Read data from a file it goes disk->disk cache->ram->cpu cache/s->cpu --><p>When reading data from a file, it is first transferred from the disk
to the disk cache and then to the RAM (the computer’s main memory, where
variables are stored). The latency to access files on disk is another
order of magnitude higher than accessing normal variables.</p>
<p>As such, disk accesses benefit from sequential accesses and reading
larger blocks together rather than single variables. Python’s
<code>io</code> package is already buffered, so automatically handles
this for you in the background.</p>
<p>However before a file can be read, the file system on the disk must
be polled to transform the file path to its address on disk to initiate
the transfer (or throw an exception).</p>
<p>Following the common theme of this episode, accessing randomly
scattered files can be significantly slower than accessing a single
larger file of the same size. This is because for each file accessed,
the file system must be polled to transform the file path to an address
on disk. Traditional hard disk drives particularly suffer, as the read
head must physically move to locate data.</p>
<p>Hence, it can be wise to avoid storing outputs in many individual
files and to instead create a larger output file.</p>
<p>This is even visible outside of your own code. If you try to
upload/download 1 GB to HPC. The transfer will be significantly faster,
assuming good internet bandwidth, if that’s a single file rather than
thousands.</p>
<p>The below example code runs a small benchmark, whereby 10MB is
written to disk and read back whilst being timed. In one case this is as
a single file, and in the other, 1000 file segments.</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">import</span> os, time</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="co"># Generate 10MB</span></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>data_len <span class="op">=</span> <span class="dv">10000000</span></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>data <span class="op">=</span> os.urandom(data_len)</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a>file_ct <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>file_len <span class="op">=</span> <span class="bu">int</span>(data_len<span class="op">/</span>file_ct)</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a><span class="co"># Write one large file</span></span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a>start <span class="op">=</span> time.perf_counter()</span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a>large_file <span class="op">=</span> <span class="bu">open</span>(<span class="st">"large.bin"</span>, <span class="st">"wb"</span>)</span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a>large_file.write(data)</span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a>large_file.close ()</span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a>large_write_s <span class="op">=</span> time.perf_counter() <span class="op">-</span> start</span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a><span class="co"># Write multiple small files</span></span>
<span id="cb1-15"><a href="#cb1-15" tabindex="-1"></a>start <span class="op">=</span> time.perf_counter()</span>
<span id="cb1-16"><a href="#cb1-16" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(file_ct):</span>
<span id="cb1-17"><a href="#cb1-17" tabindex="-1"></a>    small_file <span class="op">=</span> <span class="bu">open</span>(<span class="ss">f"small_</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">.bin"</span>, <span class="st">"wb"</span>)</span>
<span id="cb1-18"><a href="#cb1-18" tabindex="-1"></a>    small_file.write(data[file_len<span class="op">*</span>i:file_len<span class="op">*</span>(i<span class="op">+</span><span class="dv">1</span>)])</span>
<span id="cb1-19"><a href="#cb1-19" tabindex="-1"></a>    small_file.close()</span>
<span id="cb1-20"><a href="#cb1-20" tabindex="-1"></a>small_write_s <span class="op">=</span> time.perf_counter() <span class="op">-</span> start</span>
<span id="cb1-21"><a href="#cb1-21" tabindex="-1"></a><span class="co"># Read back the large file</span></span>
<span id="cb1-22"><a href="#cb1-22" tabindex="-1"></a>start <span class="op">=</span> time.perf_counter()</span>
<span id="cb1-23"><a href="#cb1-23" tabindex="-1"></a>large_file <span class="op">=</span> <span class="bu">open</span>(<span class="st">"large.bin"</span>, <span class="st">"rb"</span>)</span>
<span id="cb1-24"><a href="#cb1-24" tabindex="-1"></a>t <span class="op">=</span> large_file.read(data_len)</span>
<span id="cb1-25"><a href="#cb1-25" tabindex="-1"></a>large_file.close ()</span>
<span id="cb1-26"><a href="#cb1-26" tabindex="-1"></a>large_read_s <span class="op">=</span> time.perf_counter() <span class="op">-</span> start</span>
<span id="cb1-27"><a href="#cb1-27" tabindex="-1"></a><span class="co"># Read back the small files</span></span>
<span id="cb1-28"><a href="#cb1-28" tabindex="-1"></a>start <span class="op">=</span> time.perf_counter()</span>
<span id="cb1-29"><a href="#cb1-29" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(file_ct):</span>
<span id="cb1-30"><a href="#cb1-30" tabindex="-1"></a>    small_file <span class="op">=</span> <span class="bu">open</span>(<span class="ss">f"small_</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">.bin"</span>, <span class="st">"rb"</span>)</span>
<span id="cb1-31"><a href="#cb1-31" tabindex="-1"></a>    t <span class="op">=</span> small_file.read(file_len)</span>
<span id="cb1-32"><a href="#cb1-32" tabindex="-1"></a>    small_file.close()</span>
<span id="cb1-33"><a href="#cb1-33" tabindex="-1"></a>small_read_s <span class="op">=</span> time.perf_counter() <span class="op">-</span> start</span>
<span id="cb1-34"><a href="#cb1-34" tabindex="-1"></a><span class="co"># Print Summary</span></span>
<span id="cb1-35"><a href="#cb1-35" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span><span class="dv">1</span><span class="sc">:5d}</span><span class="ss">x</span><span class="sc">{</span>data_len<span class="op">/</span><span class="dv">1000000</span><span class="sc">}</span><span class="ss">MB Write: </span><span class="sc">{</span>large_write_s<span class="sc">:.5f}</span><span class="ss"> seconds"</span>)</span>
<span id="cb1-36"><a href="#cb1-36" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>file_ct<span class="sc">:5d}</span><span class="ss">x</span><span class="sc">{</span>file_len<span class="op">/</span><span class="dv">1000</span><span class="sc">}</span><span class="ss">KB Write: </span><span class="sc">{</span>small_write_s<span class="sc">:.5f}</span><span class="ss"> seconds"</span>)</span>
<span id="cb1-37"><a href="#cb1-37" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span><span class="dv">1</span><span class="sc">:5d}</span><span class="ss">x</span><span class="sc">{</span>data_len<span class="op">/</span><span class="dv">1000000</span><span class="sc">}</span><span class="ss">MB Read: </span><span class="sc">{</span>large_read_s<span class="sc">:.5f}</span><span class="ss"> seconds"</span>)</span>
<span id="cb1-38"><a href="#cb1-38" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>file_ct<span class="sc">:5d}</span><span class="ss">x</span><span class="sc">{</span>file_len<span class="op">/</span><span class="dv">1000</span><span class="sc">}</span><span class="ss">KB Read: </span><span class="sc">{</span>small_read_s<span class="sc">:.5f}</span><span class="ss"> seconds"</span>)</span>
<span id="cb1-39"><a href="#cb1-39" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>file_ct<span class="sc">:5d}</span><span class="ss">x</span><span class="sc">{</span>file_len<span class="op">/</span><span class="dv">1000</span><span class="sc">}</span><span class="ss">KB Write was </span><span class="sc">{</span>small_write_s<span class="op">/</span>large_write_s<span class="sc">:.1f}</span><span class="ss"> slower than 1x</span><span class="sc">{</span>data_len<span class="op">/</span><span class="dv">1000000</span><span class="sc">}</span><span class="ss">MB Write"</span>)</span>
<span id="cb1-40"><a href="#cb1-40" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>file_ct<span class="sc">:5d}</span><span class="ss">x</span><span class="sc">{</span>file_len<span class="op">/</span><span class="dv">1000</span><span class="sc">}</span><span class="ss">KB Read was </span><span class="sc">{</span>small_read_s<span class="op">/</span>large_read_s<span class="sc">:.1f}</span><span class="ss"> slower than 1x</span><span class="sc">{</span>data_len<span class="op">/</span><span class="dv">1000000</span><span class="sc">}</span><span class="ss">MB Read"</span>)</span>
<span id="cb1-41"><a href="#cb1-41" tabindex="-1"></a><span class="co"># Cleanup</span></span>
<span id="cb1-42"><a href="#cb1-42" tabindex="-1"></a>os.remove(<span class="st">"large.bin"</span>)</span>
<span id="cb1-43"><a href="#cb1-43" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(file_ct):</span>
<span id="cb1-44"><a href="#cb1-44" tabindex="-1"></a>    os.remove(<span class="ss">f"small_</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">.bin"</span>)</span></code></pre>
</div>
<p>Running this locally, with an SSD I received the following
timings.</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">SH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode sh" tabindex="0"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>    <span class="ex">1x10.0MB</span> Write: 0.00198 seconds</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a> <span class="ex">1000x10.0KB</span> Write: 0.14886 seconds</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>    <span class="ex">1x10.0MB</span> Read: 0.00478 seconds</span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a> <span class="ex">1000x10.0KB</span> Read: 2.50339 seconds</span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a> <span class="ex">1000x10.0KB</span> Write was 75.1 slower than 1x10.0MB Write</span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a> <span class="ex">1000x10.0KB</span> Read was 523.9 slower than 1x10.0MB Read</span></code></pre>
</div>
<p>Repeated runs show some noise to the timing, however the slowdown is
consistently the same order of magnitude slower when split across
multiple files.</p>
<p>You might not even be reading 1000 different files. You could be
reading the same file multiple times, rather than reading it once and
retaining it in memory during execution. An even greater overhead would
apply.</p>
</section><section><h2 class="section-heading" id="accessing-the-network">Accessing the Network<a class="anchor" aria-label="anchor" href="#accessing-the-network"></a>
</h2>
<hr class="half-width">
<p>When transferring files over a network, similar effects apply. There
is a fixed overhead for every file transfer (no matter how big the
file), so downloading many small files will be slower than downloading a
single large file of the same total size.</p>
<p>Because of this overhead, downloading many small files often does not
use all the available bandwidth. It may be possible to speed things up
by parallelising downloads.</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="im">from</span> concurrent.futures <span class="im">import</span> ThreadPoolExecutor, as_completed</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a><span class="im">from</span> timeit <span class="im">import</span> timeit</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a><span class="im">import</span> requests  <span class="co"># install with `pip install requests`</span></span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a><span class="kw">def</span> download_file(url, filename):</span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>    response <span class="op">=</span> requests.get(url)</span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(filename, <span class="st">'wb'</span>) <span class="im">as</span> f:</span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a>        f.write(response.content)</span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a>    <span class="cf">return</span> filename</span>
<span id="cb3-11"><a href="#cb3-11" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" tabindex="-1"></a>downloaded_files <span class="op">=</span> []</span>
<span id="cb3-13"><a href="#cb3-13" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" tabindex="-1"></a><span class="kw">def</span> sequentialDownload():</span>
<span id="cb3-15"><a href="#cb3-15" tabindex="-1"></a>    <span class="cf">for</span> mass <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10</span>, <span class="dv">20</span>):</span>
<span id="cb3-16"><a href="#cb3-16" tabindex="-1"></a>        url <span class="op">=</span> <span class="ss">f"https://github.com/SNEWS2/snewpy-models-ccsn/raw/refs/heads/main/models/Warren_2020/stir_a1.23/stir_multimessenger_a1.23_m</span><span class="sc">{</span>mass<span class="sc">}</span><span class="ss">.0.h5"</span></span>
<span id="cb3-17"><a href="#cb3-17" tabindex="-1"></a>        f <span class="op">=</span> download_file(url, <span class="ss">f"seq_</span><span class="sc">{</span>mass<span class="sc">}</span><span class="ss">.h5"</span>)</span>
<span id="cb3-18"><a href="#cb3-18" tabindex="-1"></a>        downloaded_files.append(f)</span>
<span id="cb3-19"><a href="#cb3-19" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" tabindex="-1"></a><span class="kw">def</span> parallelDownload():</span>
<span id="cb3-21"><a href="#cb3-21" tabindex="-1"></a>    <span class="co"># Initialise a pool of 6 threads to share the workload</span></span>
<span id="cb3-22"><a href="#cb3-22" tabindex="-1"></a>    pool <span class="op">=</span> ThreadPoolExecutor(max_workers<span class="op">=</span><span class="dv">6</span>)</span>
<span id="cb3-23"><a href="#cb3-23" tabindex="-1"></a>    jobs <span class="op">=</span> []</span>
<span id="cb3-24"><a href="#cb3-24" tabindex="-1"></a>    <span class="co"># Submit each download to be executed by the thread pool</span></span>
<span id="cb3-25"><a href="#cb3-25" tabindex="-1"></a>    <span class="cf">for</span> mass <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10</span>, <span class="dv">20</span>):</span>
<span id="cb3-26"><a href="#cb3-26" tabindex="-1"></a>        url <span class="op">=</span> <span class="ss">f"https://github.com/SNEWS2/snewpy-models-ccsn/raw/refs/heads/main/models/Warren_2020/stir_a1.23/stir_multimessenger_a1.23_m</span><span class="sc">{</span>mass<span class="sc">}</span><span class="ss">.0.h5"</span></span>
<span id="cb3-27"><a href="#cb3-27" tabindex="-1"></a>        local_filename <span class="op">=</span> <span class="ss">f"par_</span><span class="sc">{</span>mass<span class="sc">}</span><span class="ss">.h5"</span></span>
<span id="cb3-28"><a href="#cb3-28" tabindex="-1"></a>        jobs.append(pool.submit(download_file, url, local_filename))</span>
<span id="cb3-29"><a href="#cb3-29" tabindex="-1"></a></span>
<span id="cb3-30"><a href="#cb3-30" tabindex="-1"></a>    <span class="co"># Collect the results (and errors) as the jobs are completed</span></span>
<span id="cb3-31"><a href="#cb3-31" tabindex="-1"></a>    <span class="cf">for</span> result <span class="kw">in</span> as_completed(jobs):        </span>
<span id="cb3-32"><a href="#cb3-32" tabindex="-1"></a>        <span class="cf">if</span> result.exception() <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb3-33"><a href="#cb3-33" tabindex="-1"></a>            <span class="co"># handle return values of the parallelised function</span></span>
<span id="cb3-34"><a href="#cb3-34" tabindex="-1"></a>            f <span class="op">=</span> result.result()</span>
<span id="cb3-35"><a href="#cb3-35" tabindex="-1"></a>            downloaded_files.append(f)</span>
<span id="cb3-36"><a href="#cb3-36" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb3-37"><a href="#cb3-37" tabindex="-1"></a>            <span class="co"># handle errors</span></span>
<span id="cb3-38"><a href="#cb3-38" tabindex="-1"></a>            <span class="bu">print</span>(result.exception())</span>
<span id="cb3-39"><a href="#cb3-39" tabindex="-1"></a></span>
<span id="cb3-40"><a href="#cb3-40" tabindex="-1"></a>    pool.shutdown(wait<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb3-41"><a href="#cb3-41" tabindex="-1"></a></span>
<span id="cb3-42"><a href="#cb3-42" tabindex="-1"></a></span>
<span id="cb3-43"><a href="#cb3-43" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"sequentialDownload: </span><span class="sc">{</span>timeit(sequentialDownload, <span class="bu">globals</span><span class="op">=</span><span class="bu">globals</span>(), number<span class="op">=</span><span class="dv">1</span>)<span class="sc">:.3f}</span><span class="ss"> s"</span>)</span>
<span id="cb3-44"><a href="#cb3-44" tabindex="-1"></a><span class="bu">print</span>(downloaded_files)</span>
<span id="cb3-45"><a href="#cb3-45" tabindex="-1"></a>downloaded_files <span class="op">=</span> []</span>
<span id="cb3-46"><a href="#cb3-46" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"parallelDownload: </span><span class="sc">{</span>timeit(parallelDownload, <span class="bu">globals</span><span class="op">=</span><span class="bu">globals</span>(), number<span class="op">=</span><span class="dv">1</span>)<span class="sc">:.3f}</span><span class="ss"> s"</span>)</span>
<span id="cb3-47"><a href="#cb3-47" tabindex="-1"></a><span class="bu">print</span>(downloaded_files)</span></code></pre>
</div>
<p>Depending on your internet connection, results may vary
significantly, but the parallel download will usually be quite a bit
faster. Note also that the order in which the parallel downloads finish
will vary.</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>sequentialDownload: 3.225 s
['seq_10.h5', 'seq_11.h5', 'seq_12.h5', 'seq_13.h5', 'seq_14.h5', 'seq_15.h5', 'seq_16.h5', 'seq_17.h5', 'seq_18.h5', 'seq_19.h5']
parallelDownload: 0.285 s
['par_11.h5', 'par_12.h5', 'par_15.h5', 'par_13.h5', 'par_10.h5', 'par_14.h5', 'par_16.h5', 'par_19.h5', 'par_17.h5', 'par_18.h5']</code></pre>
</div>
</section><section><h2 class="section-heading" id="latency-overview">Latency Overview<a class="anchor" aria-label="anchor" href="#latency-overview"></a>
</h2>
<hr class="half-width">
<p>Latency can have a big impact on the speed that a program executes,
the below graph demonstrates this. Note the log scale!</p>
<figure><img src="fig/latency.png" alt="A horizontal bar chart displaying the relative latencies for L1/L2/L3 cache, RAM, SSD, HDD and a packet being sent from London to California and back. These latencies range from 1 nanosecond to 140 milliseconds and are displayed with a log scale." class="figure mx-auto d-block"><div class="figcaption">A graph demonstrating the wide variety of
latencies a programmer may experience when accessing data.</div>
</figure><p>L1/L2/L3 caches are where your most recently accessed variables are
stored inside the CPU, whereas RAM is where most of your variables will
be found.</p>
<p>The lower the latency typically the higher the effective bandwidth
(L1 and L2 cache have 1 TB/s, RAM 100 GB/s, SSDs up to 32 GB/s, HDDs up
to 150 MB/s), making large memory transactions even slower.</p>
</section><section><h2 class="section-heading" id="memory-allocation-is-not-free">Memory Allocation is not Free<a class="anchor" aria-label="anchor" href="#memory-allocation-is-not-free"></a>
</h2>
<hr class="half-width">
<!-- Even "garbage collected" languages like Python have a cost. --><p>When a variable is created, memory must be located for it,
potentially requested from the operating system. This gives it an
overhead versus reusing existing allocations, or avoiding redundant
temporary allocations entirely.</p>
<p>Within Python memory is not explicitly allocated and deallocated,
instead it is automatically allocated and later “garbage collected”. The
costs are still there, this just means that Python programmers have less
control over where they occur.</p>
<!-- Based on the same premise as first example from Chapter 6 High Perf Python-->
<p>The below implementation of the <a href="https://en.wikipedia.org/wiki/Heat_equation" class="external-link">heat-equation</a>,
reallocates <code>out_grid</code>, a large 2 dimensional (500x500) list
each time <code>update()</code> is called which progresses the
model.</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>grid_shape <span class="op">=</span> (<span class="dv">512</span>, <span class="dv">512</span>)</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a><span class="kw">def</span> update(grid, a_dt):</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>    x_max, y_max <span class="op">=</span> grid_shape</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>    out_grid <span class="op">=</span> [[<span class="fl">0.0</span> <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(y_max)] <span class="op">*</span> y_max <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(x_max)]</span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(x_max):</span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(y_max):</span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a>            out_xx <span class="op">=</span> grid[(i<span class="op">-</span><span class="dv">1</span>)<span class="op">%</span>x_max][j] <span class="op">-</span> <span class="dv">2</span> <span class="op">*</span> grid[i][j] <span class="op">+</span> grid[(i<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span>x_max][j]</span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a>            out_yy <span class="op">=</span> grid[i][(j<span class="op">-</span><span class="dv">1</span>)<span class="op">%</span>y_max] <span class="op">-</span> <span class="dv">2</span> <span class="op">*</span> grid[i][j] <span class="op">+</span> grid[i][(j<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span>y_max]</span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a>            out_grid[i][j] <span class="op">=</span> grid[i][j] <span class="op">+</span> (out_xx <span class="op">+</span> out_yy) <span class="op">*</span> a_dt </span>
<span id="cb5-11"><a href="#cb5-11" tabindex="-1"></a>    <span class="cf">return</span> out_grid</span>
<span id="cb5-12"><a href="#cb5-12" tabindex="-1"></a>    </span>
<span id="cb5-13"><a href="#cb5-13" tabindex="-1"></a><span class="kw">def</span> heat_equation(steps):</span>
<span id="cb5-14"><a href="#cb5-14" tabindex="-1"></a>    x_max, y_max <span class="op">=</span> grid_shape</span>
<span id="cb5-15"><a href="#cb5-15" tabindex="-1"></a>    grid <span class="op">=</span> [[<span class="fl">0.0</span>] <span class="op">*</span> y_max <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(x_max)]</span>
<span id="cb5-16"><a href="#cb5-16" tabindex="-1"></a>    <span class="co"># Init central point to diffuse</span></span>
<span id="cb5-17"><a href="#cb5-17" tabindex="-1"></a>    grid[<span class="bu">int</span>(x_max<span class="op">/</span><span class="dv">2</span>)][<span class="bu">int</span>(y_max<span class="op">/</span><span class="dv">2</span>)] <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb5-18"><a href="#cb5-18" tabindex="-1"></a>    <span class="co"># Run steps</span></span>
<span id="cb5-19"><a href="#cb5-19" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(steps):</span>
<span id="cb5-20"><a href="#cb5-20" tabindex="-1"></a>        grid <span class="op">=</span> update(grid, <span class="fl">0.1</span>)</span>
<span id="cb5-21"><a href="#cb5-21" tabindex="-1"></a></span>
<span id="cb5-22"><a href="#cb5-22" tabindex="-1"></a>heat_equation(<span class="dv">100</span>)</span></code></pre>
</div>
<p>Line profiling demonstrates that function takes up over 55 seconds of
the total runtime, with the cost of allocating the temporary
<code>out_grid</code> list to be 39.3% of the total runtime of that
function!</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Total time: 55.4675 s
File: heat_equation.py
Function: update at line 4

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     3                                           @profile
     4                                           def update(grid, a_dt):
     5       100        127.7      1.3      0.0      x_max, y_max = grid_shape
     6       100   21822304.9 218223.0     39.3      out_grid = [[0.0 for x in range(y_max)] * y_max for x in range(x_m…
     7     51300       7741.9      0.2      0.0      for i in range(x_max):
     8  26265600    3632718.1      0.1      6.5          for j in range(y_max):
     9  26214400   11207717.9      0.4     20.2              out_xx = grid[(i-1)%x_max][j] - 2 * grid[i][j] + grid[(i+1…
    10  26214400   11163116.5      0.4     20.1              out_yy = grid[i][(j-1)%y_max] - 2 * grid[i][j] + grid[i][(…
    11  26214400    7633720.1      0.3     13.8              out_grid[i][j] = grid[i][j] + (out_xx + out_yy) * a_dt
    12       100         27.8      0.3      0.0      return out_grid</code></pre>
</div>
<p>If instead <code>out_grid</code> is double buffered, such that two
buffers are allocated outside the function, which are swapped after each
call to update().</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>grid_shape <span class="op">=</span> (<span class="dv">512</span>, <span class="dv">512</span>)</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a><span class="kw">def</span> update(grid, a_dt, out_grid):</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>    x_max, y_max <span class="op">=</span> grid_shape</span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(x_max):</span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(y_max):</span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a>            out_xx <span class="op">=</span> grid[(i<span class="op">-</span><span class="dv">1</span>)<span class="op">%</span>x_max][j] <span class="op">-</span> <span class="dv">2</span> <span class="op">*</span> grid[i][j] <span class="op">+</span> grid[(i<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span>x_max][j]</span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a>            out_yy <span class="op">=</span> grid[i][(j<span class="op">-</span><span class="dv">1</span>)<span class="op">%</span>y_max] <span class="op">-</span> <span class="dv">2</span> <span class="op">*</span> grid[i][j] <span class="op">+</span> grid[i][(j<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span>y_max]</span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a>            out_grid[i][j] <span class="op">=</span> grid[i][j] <span class="op">+</span> (out_xx <span class="op">+</span> out_yy) <span class="op">*</span> a_dt </span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a>    </span>
<span id="cb7-11"><a href="#cb7-11" tabindex="-1"></a><span class="kw">def</span> heat_equation(steps):</span>
<span id="cb7-12"><a href="#cb7-12" tabindex="-1"></a>    x_max, y_max <span class="op">=</span> grid_shape</span>
<span id="cb7-13"><a href="#cb7-13" tabindex="-1"></a>    grid <span class="op">=</span> [[<span class="fl">0.0</span> <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(y_max)] <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(x_max)]</span>
<span id="cb7-14"><a href="#cb7-14" tabindex="-1"></a>    out_grid <span class="op">=</span> [[<span class="fl">0.0</span> <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(y_max)] <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(x_max)]  <span class="co"># Allocate a second buffer once</span></span>
<span id="cb7-15"><a href="#cb7-15" tabindex="-1"></a>    <span class="co"># Init central point to diffuse</span></span>
<span id="cb7-16"><a href="#cb7-16" tabindex="-1"></a>    grid[<span class="bu">int</span>(x_max<span class="op">/</span><span class="dv">2</span>)][<span class="bu">int</span>(y_max<span class="op">/</span><span class="dv">2</span>)] <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb7-17"><a href="#cb7-17" tabindex="-1"></a>    <span class="co"># Run steps</span></span>
<span id="cb7-18"><a href="#cb7-18" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(steps):</span>
<span id="cb7-19"><a href="#cb7-19" tabindex="-1"></a>        update(grid, <span class="fl">0.1</span>, out_grid)  <span class="co"># Pass the output buffer</span></span>
<span id="cb7-20"><a href="#cb7-20" tabindex="-1"></a>        grid, out_grid <span class="op">=</span> out_grid, grid  <span class="co"># Swap buffers</span></span>
<span id="cb7-21"><a href="#cb7-21" tabindex="-1"></a></span>
<span id="cb7-22"><a href="#cb7-22" tabindex="-1"></a>heat_equation(<span class="dv">100</span>)</span></code></pre>
</div>
<p>The total time reduces to 34 seconds, reducing the runtime by 39%
inline with the removed allocation.</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Total time: 34.0597 s
File: heat_equation.py
Function: update at line 3

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     3                                           @profile
     4                                           def update(grid, a_dt, out_grid):
     5       100         43.5      0.4      0.0      x_max, y_max = grid_shape
     6     51300       7965.8      0.2      0.0      for i in range(x_max):
     7  26265600    3569519.4      0.1     10.5          for j in range(y_max):
     8  26214400   11291491.6      0.4     33.2              out_xx = grid[(i-1)%x_max][j] - 2 * grid[i][j] + grid[(i+1…
     9  26214400   11409533.7      0.4     33.5              out_yy = grid[i][(j-1)%y_max] - 2 * grid[i][j] + grid[i][(…
    10  26214400    7781156.4      0.3     22.8              out_grid[i][j] = grid[i][j] + (out_xx + out_yy) * a_dt</code></pre>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>One large file is preferable to many small files.</li>
<li>Network requests can be parallelised to reduce the impact of fixed
overheads.</li>
<li>Memory allocation is not free, avoiding destroying and recreating
objects can improve performance.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-optimisation-conclusion"><p>Content from <a href="optimisation-conclusion.html">Optimisation Conclusion</a></p>
<hr>
<p>Last updated on 2025-05-11 |

        <a href="https://github.com/RSE-Sheffield/pando-python/edit/main/episodes/optimisation-conclusion.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What has been learnt about writing performant Python?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Review what has been learnt about writing performant Python</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<p>This concludes the optimisation portion of the course.</p>
<p>An overview of how Python operates and the most important practices
for achieving performant code have been introduced.</p>
<p>Hopefully with the information from this course you will be in a
better position to investigate and optimise the performance of your own
code.</p>
<p>This course’s website can be used as a reference manual when
profiling your own code.</p>
<div id="your-feedback-is-required" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="your-feedback-is-required" class="callout-inner">
<h3 class="callout-title">Your Feedback is Required!</h3>
<div class="callout-content">
<p>Please complete <a href="https://forms.gle/C82uWBEou3FMrQs99" class="external-link">this
Google form</a> to let us know what you think we’ve missed.</p>
<p>Your feedback enables us to improve the course for future
attendees!</p>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>Using Python Language Features and the Standard Library
<ul>
<li>Python is an interpreted language. This adds an additional overhead
at runtime to the execution of Python code. Many core Python functions
are implemented in faster C/C++, free from this overhead.</li>
<li>Where possible, use built-in functions (like <code>sum()</code>,
<code>min()</code> or <code>max()</code>), language features (like list
comprehensions) and standard library functionality (like
<code>str.split()</code>) instead of re-inventing the wheel. This makes
your code more readable and is often more performant.</li>
</ul>
</li>
<li>Data Structures &amp; Algorithms
<ul>
<li>List comprehension should be preferred when constructing lists.</li>
<li>Where appropriate, Tuples and Generator functions should be
preferred over Python lists.</li>
<li>Dictionaries and sets are appropriate for storing a collection of
unique data with no intrinsic order for random access.</li>
<li>When used appropriately, dictionaries and sets are significantly
faster than lists.</li>
<li>If searching a list or array is required, it should be sorted and
searched using <code>bisect_left()</code> (binary search).</li>
</ul>
</li>
<li>Minimise Python Written
<ul>
<li>Like many core Python functions, NumPy functions are implemented in
faster C/C++.</li>
<li>Additionally, NumPy can take advantage of vectorisation to process
arrays, which can greatly improve performance.</li>
<li>Pandas’ data tables store columns as arrays, therefore operations
applied to columns can take advantage of NumPys vectorisation.</li>
</ul>
</li>
<li>Newer is Often Faster
<ul>
<li>Where feasible, the latest version of Python and packages should be
used as they can include significant free improvements to the
performance of your code.</li>
<li>There is a risk that updating Python or packages will not be
possible to due to version incompatibilities or will require breaking
changes to your code.</li>
<li>Changes to packages may impact results output by your code, ensure
you have a method of validation ready prior to attempting upgrades.</li>
</ul>
</li>
<li>How Latency Affects Performance
<ul>
<li>One large file is preferable to many small files.</li>
<li>Network requests can be parallelised to reduce the impact of fixed
overheads.</li>
<li>Memory allocation is not free, avoiding destroying and recreating
objects can improve performance.</li>
</ul>
</li>
</ul>
</div>
</div>
</div></section>
</div>
    </main>
</div>
<!-- END  : inst/pkgdown/templates/content-extra.html -->

      </div>
<!--/div.row-->
      		<footer class="row footer mx-md-3"><hr>
<div class="col-md-2">
        <a href="https://docs.hpc.shef.ac.uk/en/latest/stanage/index.html" class="external-link">
          <img alt="Stanage HPC" src="https://docs.hpc.shef.ac.uk/en/latest/_images/Stanage_Black.png" style="width: 100%;" class="dark-invert"></a>
        <p><a href="https://sites.google.com/sheffield.ac.uk/research-training/research-training" class="external-link">Research Computing Training Home</a></p>
			</div>
			<div class="col-md-5">
        <p>Lesson developed by <a href="https://rse.shef.ac.uk" class="external-link">RSE</a> &amp; <a href="https://www.sheffield.ac.uk/it-services/research" class="external-link">RIT</a></p>
        <p>

          <a href="https://github.com/RSE-Sheffield/pando-python/edit/main/README.md" class="external-link">Edit on GitHub</a>


        | <a href="https://github.com/RSE-Sheffield/pando-python/blob/main/CONTRIBUTING.md" class="external-link">Contributing</a>
        | <a href="https://github.com/RSE-Sheffield/pando-python/" class="external-link">Source</a>
        </p>
		<p>
          <a href="https://github.com/RSE-Sheffield/pando-python/blob/main/CITATION.cff" class="external-link">Cite</a> | <a href="mailto:robert.chisholm@sheffield.ac.uk">Contact</a> | <a href="https://carpentries.org/about/" class="external-link">About</a> | <a href="CODE_OF_CONDUCT.html">Code of Conduct</a>
        </p>
		</div>
		<div class="col-md-5">

        <p>Materials licensed under <a href="LICENSE.html">CC-BY 4.0</a> by the authors</p>


        <!--<p>Template licensed under <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC-BY 4.0</a> by <a href="https://carpentries.org/">The Carpentries</a></p>-->
        <!--<p>Built with <a href="https://github.com/carpentries/sandpaper/tree/0.16.12">sandpaper (0.16.12)</a>, <a href="https://github.com/carpentries/pegboard/tree/0.7.9">pegboard (0.7.9)</a>, and <a href="https://github.com/RSE-Sheffield/uos-varnish/tree/main">varnish (1.0.4)</a></p>-->
        <p><a href="https://creativecommons.org/licenses/by-sa/4.0/" class="external-link">Template licensed under CC-BY 4.0</a> by <a href="https://carpentries.org" class="external-link">The Carpentries</a></p>
        <p>Built with <a href="https://github.com/carpentries/sandpaper/tree/0.16.12" class="external-link">sandpaper (0.16.12)</a>,
        <a href="https://github.com/carpentries/pegboard/tree/0.7.9" class="external-link">pegboard (0.7.9)</a>,
      and <a href="https://github.com/RSE-Sheffield/uos-varnish/tree/main" class="external-link">varnish (1.0.4) [UoS fork]</a>.</p>
			</div>
		</footer>
</div> <!-- / div.container -->
	<div id="to-top">
		<a href="#top">
      <i class="search-icon" data-feather="arrow-up" role="img" aria-label="Back To Top"></i><br><!-- <span class="d-none d-sm-none d-md-none d-lg-none d-xl-block">Back</span> To Top --><span class="d-none d-sm-none d-md-none d-lg-none d-xl-block">Back</span> To Top
		</a>
	</div>
  <script type="application/ld+json">
    {
  "@context": "https://schema.org",
  "@type": "LearningResource",
  "@id": "https://rse.shef.ac.uk/pando-python/aio.html",
  "inLanguage": "en",
  "dct:conformsTo": "https://bioschemas.org/profiles/LearningResource/1.0-RELEASE",
  "description": "A Carpentries Lesson teaching foundational data and coding skills to researchers worldwide",
  "keywords": "python, profiling, optimisation, data structures, algorithms",
  "name": "All in One View",
  "creativeWorkStatus": "active",
  "url": "https://rse.shef.ac.uk/pando-python/aio.html",
  "identifier": "https://rse.shef.ac.uk/pando-python/aio.html",
  "dateCreated": "2024-02-01",
  "dateModified": "2025-07-15",
  "datePublished": "2025-07-15"
}

  </script><script>
		feather.replace();
	</script><script defer src="https://cloud.umami.is/script.js" data-website-id="95b3ca57-3bd9-47b0-b1ca-fe819ef65c80"></script>
</body>
</html><!-- END:   inst/pkgdown/templates/layout.html-->

